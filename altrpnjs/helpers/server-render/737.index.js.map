{"version":3,"sources":["webpack:///./node_modules/@socket.io/component-emitter/index.js","webpack:///./node_modules/axios/index.js","webpack:///./node_modules/axios/lib/adapters/http.js","webpack:///./node_modules/axios/lib/adapters/xhr.js","webpack:///./node_modules/axios/lib/axios.js","webpack:///./node_modules/axios/lib/cancel/Cancel.js","webpack:///./node_modules/axios/lib/cancel/CancelToken.js","webpack:///./node_modules/axios/lib/cancel/isCancel.js","webpack:///./node_modules/axios/lib/core/Axios.js","webpack:///./node_modules/axios/lib/core/InterceptorManager.js","webpack:///./node_modules/axios/lib/core/buildFullPath.js","webpack:///./node_modules/axios/lib/core/createError.js","webpack:///./node_modules/axios/lib/core/dispatchRequest.js","webpack:///./node_modules/axios/lib/core/enhanceError.js","webpack:///./node_modules/axios/lib/core/mergeConfig.js","webpack:///./node_modules/axios/lib/core/settle.js","webpack:///./node_modules/axios/lib/core/transformData.js","webpack:///./node_modules/axios/lib/defaults.js","webpack:///./node_modules/axios/lib/env/data.js","webpack:///./node_modules/axios/lib/helpers/bind.js","webpack:///./node_modules/axios/lib/helpers/buildURL.js","webpack:///./node_modules/axios/lib/helpers/combineURLs.js","webpack:///./node_modules/axios/lib/helpers/cookies.js","webpack:///./node_modules/axios/lib/helpers/isAbsoluteURL.js","webpack:///./node_modules/axios/lib/helpers/isAxiosError.js","webpack:///./node_modules/axios/lib/helpers/isURLSameOrigin.js","webpack:///./node_modules/axios/lib/helpers/normalizeHeaderName.js","webpack:///./node_modules/axios/lib/helpers/parseHeaders.js","webpack:///./node_modules/axios/lib/helpers/spread.js","webpack:///./node_modules/axios/lib/helpers/validator.js","webpack:///./node_modules/axios/lib/utils.js","webpack:///./node_modules/backo2/index.js","webpack:///./node_modules/debug/src/browser.js","webpack:///./node_modules/debug/src/common.js","webpack:///./node_modules/debug/src/index.js","webpack:///./node_modules/debug/src/node.js","webpack:///./node_modules/engine.io-client/node_modules/ws/lib/buffer-util.js","webpack:///./node_modules/engine.io-client/node_modules/ws/lib/constants.js","webpack:///./node_modules/engine.io-client/node_modules/ws/lib/event-target.js","webpack:///./node_modules/engine.io-client/node_modules/ws/lib/extension.js","webpack:///./node_modules/engine.io-client/node_modules/ws/lib/limiter.js","webpack:///./node_modules/engine.io-client/node_modules/ws/lib/permessage-deflate.js","webpack:///./node_modules/engine.io-client/node_modules/ws/lib/receiver.js","webpack:///./node_modules/engine.io-client/node_modules/ws/lib/sender.js","webpack:///./node_modules/engine.io-client/node_modules/ws/lib/stream.js","webpack:///./node_modules/engine.io-client/node_modules/ws/lib/subprotocol.js","webpack:///./node_modules/engine.io-client/node_modules/ws/lib/validation.js","webpack:///./node_modules/engine.io-client/node_modules/ws/lib/websocket-server.js","webpack:///./node_modules/engine.io-client/node_modules/ws/lib/websocket.js","webpack:///./node_modules/follow-redirects/debug.js","webpack:///./node_modules/follow-redirects/index.js","webpack:///./node_modules/has-flag/index.js","webpack:///./node_modules/ms/index.js","webpack:///./node_modules/parseqs/index.js","webpack:///./node_modules/parseuri/index.js","webpack:///./node_modules/socket.io-client/build/esm-debug/url.js","webpack:///./node_modules/engine.io-client/build/esm-debug/transports/xmlhttprequest.js","webpack:///./node_modules/engine.io-client/build/esm-debug/globalThis.js","webpack:///./node_modules/engine.io-client/build/esm-debug/util.js","webpack:///./node_modules/engine.io-parser/build/esm/commons.js","webpack:///./node_modules/engine.io-parser/build/esm/encodePacket.js","webpack:///./node_modules/engine.io-parser/build/esm/decodePacket.js","webpack:///./node_modules/engine.io-parser/build/esm/index.js","webpack:///./node_modules/engine.io-client/build/esm-debug/transport.js","webpack:///./node_modules/engine.io-client/build/esm-debug/transports/polling.js","webpack:///./node_modules/engine.io-client/build/esm-debug/transports/polling-xhr.js","webpack:///./node_modules/engine.io-client/node_modules/ws/wrapper.mjs","webpack:///./node_modules/engine.io-client/build/esm-debug/transports/websocket-constructor.js","webpack:///./node_modules/engine.io-client/build/esm-debug/transports/websocket.js","webpack:///./node_modules/engine.io-client/build/esm-debug/transports/index.js","webpack:///./node_modules/engine.io-client/build/esm-debug/socket.js","webpack:///./node_modules/engine.io-client/build/esm-debug/index.js","webpack:///./node_modules/socket.io-parser/build/esm-debug/is-binary.js","webpack:///./node_modules/socket.io-parser/build/esm-debug/binary.js","webpack:///./node_modules/socket.io-parser/build/esm-debug/index.js","webpack:///./node_modules/socket.io-client/build/esm-debug/on.js","webpack:///./node_modules/socket.io-client/build/esm-debug/socket.js","webpack:///./node_modules/socket.io-client/build/esm-debug/manager.js","webpack:///./node_modules/socket.io-client/build/esm-debug/index.js","webpack:///./node_modules/supports-color/index.js","webpack:///./node_modules/uuid/index.js","webpack:///./node_modules/uuid/lib/bytesToUuid.js","webpack:///./node_modules/uuid/lib/rng.js","webpack:///./node_modules/uuid/v1.js","webpack:///./node_modules/uuid/v4.js","webpack:///./node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js","webpack:///./node_modules/yeast/index.js","webpack:///./resources/modules/front-app/src/js/classes/AltrpAction.js","webpack:///./resources/modules/front-app/src/js/classes/modules/ActionsManager.js","webpack:///./resources/modules/front-app/src/js/helpers/sendEmail.js"],"names":["window","altrpHelpers","altrpLogin","altrpLogout","dataFromTable","dataToCSV","dataToXML","elementsToPdf","getAppContext","getComponentByElementId","getHTMLElementById","parseParamsFromString","getDataByPath","printElements","replaceContentWithData","scrollToElement","setDataByPath","dataToXLS","delay","altrpCompare","Resource","getWrapperHTMLElementByElement","AltrpAction","data","widgetId","element","metaMaskConnect","path","getProperty","currentValue","ethereum","success","request","method","accounts","length","requestAccounts","setProperty","init","getId","formId","indexOf","getCurrentModel","getData","formURL","getElementId","getElement","name","defaultValue","value","_","isString","getType","getFormURL","form","formsManager","registerForm","getFormId","type","result","confirmText","confirm","message","doActionForm","doActionDelay","doActionEmail","doActionRedirect","doActionToggleElements","doActionTogglePopup","doActionPrintPage","doActionPrintElements","doActionScrollToElement","doActionScrollToTop","doActionScrollToBottom","doActionTrigger","doActionPageToPDF","doActionElementsToPDF","doActionDataToCSV","doActionTableToCSV","doActionTableToXML","doActionTableToXLS","doActionLogin","doActionLogout","doActionSetData","doActionUpdateCurrentDatasources","doActionUpdateCurrentModel","doActionFormsManipulate","doActionCustomCode","doActionPlaySound","doActionCondition","doActionVIToggle","doActionOAuth","doActionSocketEmit","doActionSocketReceiver","alertText","alert","console","log","axios","io","process","env","SOCKETS_KEY","user","current_user","is_guest","guid","localStorage","getItem","setItem","uuid","on","default","customHeaders","isArray","get","bulk","customRoute","assign","bulkRequests","map","item","idx","url","submit","Promise","all","res","error","forEach","deleteFormById","_data","isEmpty","formOptions","dynamicURL","response","URL","frontAppRouter","history","goBack","innerRedirect","push","location","back","href","IDs","split","id","component","toggleElementDisplay","loadPopups","appStore","dispatch","togglePopup","print","elementsToPrint","elementId","trim","getStylesHTMLElement","stylesElement","document","head","scroller","mainScrollbars","querySelector","scrollTop","scrollTo","top","left","behavior","routeContent","getElementById","offsetHeight","filename","elements","all_sources_path","table","formattedData","each","row","Object","values","rawTemplateData","parsedTemplateData","reduce","keyValuePair","templateName","blob","link","createElement","setAttribute","createObjectURL","body","appendChild","click","removeChild","fields","field","fieldValidate","paths","setType","count","replace","v","nextIndex","isNaN","Number","isObject","items","i","listPath","list","filter","_item","change","elementRef","current","selectAll","clearValue","code","eval","modelName","currentPage","model_name","modelId","model_data","route","model","oldModel","getState","currentModel","altrpModelUpdated","isEqual","changeCurrentModel","aliases","alias","allDataSources","dataStorageUpdater","dataSourcesToUpdate","dataSource","updateCurrent","action","isFunction","fireAction","templateGUID","sendEmail","getReplacedProperty","duration","loop","playSound","compare","conditionLeft","conditionRight","loadVIPlugin","HTMLWrapper","OIDC","WebStorageStateStore","UserManager","authority","OidcClient","altrpLibs","settings","client_id","redirect_uri","post_logout_redirect_uri","response_type","scope","automaticSilentRenew","userStore","store","filterProtocolClaims","loadUserInfo","monitorSession","checkSessionInterval","_manager","manager","AltrpModel","isEditor","ActionsManager","actions","eventName","context","a","unsetProperty","preventedActions","errors","doAction","actionsManager","emailTemplateGUID","subject","from","to","attachments","templateLoader","loadTemplate","template","changeCurrentEmailTemplate","html","emailTemplatesRenderer","emailTemplate","cloneNode","style","display","outerHTML","resource","post"],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,SAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;;;AAGA;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA,GAAG;;;AAGH;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA,GAAG;;;AAGH;;AAEA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,YAAY;AACZ;;;AAGA;AACA;AACA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;AACA;;AAEA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,E;;;;;;;ACvKA,yEAAuC,C;;;;;;;;ACA1B;;AAEb,YAAY,mBAAO,CAAC,mCAAY;;AAEhC,aAAa,mBAAO,CAAC,yCAAkB;;AAEvC,oBAAoB,mBAAO,CAAC,gDAAuB;;AAEnD,eAAe,mBAAO,CAAC,8CAAuB;;AAE9C,WAAW,mBAAO,CAAC,MAAM;;AAEzB,YAAY,mBAAO,CAAC,OAAO;;AAE3B,iBAAiB,oEAAgC;;AAEjD,kBAAkB,qEAAiC;;AAEnD,UAAU,mBAAO,CAAC,KAAK;;AAEvB,WAAW,mBAAO,CAAC,MAAM;;AAEzB,cAAc,mEAAgC;;AAE9C,kBAAkB,mBAAO,CAAC,8CAAqB;;AAE/C,mBAAmB,mBAAO,CAAC,+CAAsB;;AAEjD,eAAe,mBAAO,CAAC,sCAAa;;AAEpC,aAAa,mBAAO,CAAC,2CAAkB;;AAEvC;AACA;AACA;AACA,WAAW,uBAAuB;AAClC,WAAW,iBAAiB;AAC5B,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK,EAAE;AACP;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA,OAAO;;AAEP,KAAK;AACL;AACA;AACA;;AAEA;AACA,kCAAkC;AAClC,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,OAAO;;;AAGP;AACA;AACA;AACA,KAAK;;;AAGL;;AAEA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;;AAGL;AACA,8BAA8B;;AAE9B,uBAAuB;;AAEvB,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;;AAErD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,6CAA6C;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;;AAEA;AACA,SAAS;AACT;AACA,KAAK,EAAE;;AAEP;AACA;AACA;AACA,KAAK,EAAE;;AAEP;AACA;AACA;AACA,KAAK,EAAE;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,GAAG;AACH,E;;;;;;;;ACnYa;;AAEb,YAAY,mBAAO,CAAC,mCAAY;;AAEhC,aAAa,mBAAO,CAAC,yCAAkB;;AAEvC,cAAc,mBAAO,CAAC,6CAAsB;;AAE5C,eAAe,mBAAO,CAAC,8CAAuB;;AAE9C,oBAAoB,mBAAO,CAAC,gDAAuB;;AAEnD,mBAAmB,mBAAO,CAAC,kDAA2B;;AAEtD,sBAAsB,mBAAO,CAAC,qDAA8B;;AAE5D,kBAAkB,mBAAO,CAAC,8CAAqB;;AAE/C,eAAe,mBAAO,CAAC,sCAAa;;AAEpC,aAAa,mBAAO,CAAC,2CAAkB;;AAEvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C;AAC5C;;AAEA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;;AAEA;AACA,gHAAgH;;AAEhH;;AAEA;AACA;AACA;AACA,OAAO;;;AAGP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO,YAAY;;AAEnB;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;AAGA;AACA;AACA,SAAS;AACT;;;AAGA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;;AAEA,8EAA8E;;AAE9E;AACA,MAAM;;;AAGN;AACA;AACA;AACA,kEAAkE;;AAElE;AACA,MAAM;;;AAGN;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iIAAiI;;AAEjI;AACA,MAAM;AACN;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP,KAAK;;;AAGL;AACA;AACA,KAAK;;;AAGL;AACA;AACA,KAAK;;;AAGL;AACA;AACA,KAAK;;;AAGL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;;AAGL;AACA,GAAG;AACH,E;;;;;;;;ACrNa;;AAEb,YAAY,mBAAO,CAAC,mCAAS;;AAE7B,WAAW,mBAAO,CAAC,0CAAgB;;AAEnC,YAAY,mBAAO,CAAC,wCAAc;;AAElC,kBAAkB,mBAAO,CAAC,8CAAoB;;AAE9C,eAAe,mBAAO,CAAC,sCAAY;AACnC;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;;;AAGA;AACA;AACA,wDAAwD;;AAExD,mDAAmD;;AAEnD,kCAAkC;;AAElC;AACA;AACA;;AAEA;AACA,CAAC;;;AAGD,qCAAqC;;AAErC,oBAAoB;;AAEpB,eAAe,mBAAO,CAAC,2CAAiB;AACxC,oBAAoB,mBAAO,CAAC,gDAAsB;AAClD,iBAAiB,mBAAO,CAAC,6CAAmB;AAC5C,gBAAgB,mEAA6B,CAAC;;AAE9C;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,4CAAkB,EAAE;;AAE3C,qBAAqB,mBAAO,CAAC,kDAAwB;AACrD,uBAAuB;;AAEvB,sBAAsB,S;;;;;;;;ACrDT;AACb;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wB;;;;;;;;ACjBa;;AAEb,aAAa,mBAAO,CAAC,2CAAU;AAC/B;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,mBAAmB;;AAEnB;AACA;AACA;AACA;;AAEA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA,GAAG,EAAE;;AAEL;AACA,iBAAiB;;;AAGjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,6B;;;;;;;;ACxHa;;AAEb;AACA;AACA,E;;;;;;;;ACJa;;AAEb,YAAY,mBAAO,CAAC,mCAAY;;AAEhC,eAAe,mBAAO,CAAC,8CAAqB;;AAE5C,yBAAyB,mBAAO,CAAC,qDAAsB;;AAEvD,sBAAsB,mBAAO,CAAC,kDAAmB;;AAEjD,kBAAkB,mBAAO,CAAC,8CAAe;;AAEzC,gBAAgB,mBAAO,CAAC,+CAAsB;;AAE9C;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA,8CAA8C;;AAE9C;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,yBAAyB;AACzB,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD,uB;;;;;;;;AC5Ja;;AAEb,YAAY,mBAAO,CAAC,mCAAY;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA,YAAY,OAAO;AACnB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;;;AAGA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA,oC;;;;;;;;ACxDa;;AAEb,oBAAoB,mBAAO,CAAC,mDAA0B;;AAEtD,kBAAkB,mBAAO,CAAC,iDAAwB;AAClD;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,E;;;;;;;;ACtBa;;AAEb,mBAAmB,mBAAO,CAAC,+CAAgB;AAC3C;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;;;AAGA;AACA;AACA;AACA,E;;;;;;;;AClBa;;AAEb,YAAY,mBAAO,CAAC,mCAAY;;AAEhC,oBAAoB,mBAAO,CAAC,gDAAiB;;AAE7C,eAAe,mBAAO,CAAC,6CAAoB;;AAE3C,eAAe,mBAAO,CAAC,sCAAa;;AAEpC,aAAa,mBAAO,CAAC,2CAAkB;AACvC;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;;;AAGA;AACA,uCAAuC;;AAEvC,wCAAwC;;AAExC,iGAAiG;;AAEjG,0DAA0D,qCAAqC;AAC/F;AACA;AACA,GAAG;AACH;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA,GAAG;AACH;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH,E;;;;;;;;AC7Da;AACb;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,E;;;;;;;;AC5Ca;;AAEb,YAAY,mBAAO,CAAC,mCAAU;AAC9B;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,2BAA2B;AAC3B,KAAK;AACL;AACA;;AAEA;AACA,GAAG;;;AAGH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,E;;;;;;;;AClGa;;AAEb,kBAAkB,mBAAO,CAAC,8CAAe;AACzC;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;;;AAGA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,E;;;;;;;;ACpBa;;AAEb,YAAY,mBAAO,CAAC,mCAAY;;AAEhC,eAAe,mBAAO,CAAC,sCAAe;AACtC;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,MAAM;AACjB,WAAW,eAAe;AAC1B,aAAa,EAAE;AACf;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,E;;;;;;;;ACvBa;;AAEb,YAAY,mBAAO,CAAC,mCAAS;;AAE7B,0BAA0B,mBAAO,CAAC,yDAA+B;;AAEjE,mBAAmB,mBAAO,CAAC,+CAAqB;;AAEhD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,mBAAO,CAAC,0CAAgB;AACtC,GAAG;AACH;AACA,cAAc,mBAAO,CAAC,2CAAiB;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wEAAwE;AACxE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD,0B;;;;;;;AC7HA;AACA;AACA,E;;;;;;;;ACFa;;AAEb;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;AACA;AACA,E;;;;;;;;ACZa;;AAEb,YAAY,mBAAO,CAAC,mCAAY;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,E;;;;;;;;ACjEa;AACb;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;;AAEA;AACA;AACA,E;;;;;;;;ACXa;;AAEb,YAAY,mBAAO,CAAC,mCAAY;;AAEhC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC;AACtC,KAAK;AACL;AACA,wDAAwD,wBAAwB;AAChF;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC,G;;;;;;;;AC9CY;AACb;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;ACba;;AAEb,YAAY,mBAAO,CAAC,mCAAY;AAChC;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;;;AAGA;AACA;AACA,E;;;;;;;;ACba;;AAEb,YAAY,mBAAO,CAAC,mCAAY;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC,G;;;;;;;;ACzDY;;AAEb,YAAY,mBAAO,CAAC,mCAAU;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,E;;;;;;;;ACXa;;AAEb,YAAY,mBAAO,CAAC,mCAAY,EAAE;AAClC;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA,E;;;;;;;;ACjDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,E;;;;;;;;AC1Ba;;AAEb,cAAc,mEAA8B;;AAE5C,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;;AAEA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;;AAEA;AACA,qCAAqC;;AAErC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,E;;;;;;;;AChFa;;AAEb,WAAW,mBAAO,CAAC,0CAAgB,EAAE;;;AAGrC;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;;;AAGA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB;;;AAGA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS,GAAG,SAAS;AAC5C,2BAA2B;AAC3B;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,4BAA4B;AAC5B,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;AChXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,E;;;;;;;AClFA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;AACjB,eAAe;;AAEf,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;;AAGA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yCAAyC;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,WAAW,4CAA4C;AACvD;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG,gBAAgB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,GAAG,gBAAgB;AACnB;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,GAAG,gBAAgB;AACnB;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,oCAAU;AACnC;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,E;;;;;;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mBAAO,CAAC,4BAAI;AACrC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,cAAc;AAC3B;AACA;;AAEA;AACA;;AAEA,mBAAmB,sBAAsB;AACzC;AACA,gBAAgB;AAChB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;;AAGP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA;;AAEA;AACA,OAAO,EAAE;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK,EAAE;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa;AACb;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,OAAO;AACpB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,aAAa;AACb;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uB;;;;;;;AC3QA;AACA;AACA;AACA;AACA;AACA,EAAE,2EAAwC;AAC1C,CAAC;AACD,EAAE,wEAAqC;AACvC,C;;;;;;;ACRA;AACA;AACA;AACA,YAAY,mBAAO,CAAC,KAAK;;AAEzB,aAAa,mBAAO,CAAC,MAAM;AAC3B;AACA;AACA;;;AAGA,YAAY;AACZ,WAAW;AACX,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;AACjB,eAAe,0BAA0B;AACzC;AACA;AACA;;AAEA,cAAc;;AAEd;AACA;AACA;AACA,wBAAwB,mBAAO,CAAC,wCAAgB;;AAEhD;AACA,IAAI,cAAc;AAClB;AACA,CAAC,gBAAgB,2DAA2D;AAC5E;AACA;AACA;AACA;AACA;AACA;;;AAGA,mBAAmB;AACnB;AACA,CAAC;AACD;AACA;AACA;AACA,GAAG,EAAE;;AAEL;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,CAAC,IAAI;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,mDAAmD,EAAE;AACrD,wBAAwB,WAAW,IAAI,KAAK;AAC5C;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;;AAGA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,oCAAU;AACnC;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,E;;;;;;;;AC/Ka;;AAEb;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,kEAAa;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;;AAGA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;;AAGA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,YAAY;AACxB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,mBAAO,CAAC,yIAAY;;AAEzC;AACA;;AAEA;AACA,mEAAmE;AACnE,KAAK;;AAEL;AACA;;AAEA;AACA,oDAAoD;AACpD;;AAEA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;ACpIa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;ACXa;;AAEb;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,kEAAa;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,OAAO;AACpB;AACA,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,EAAE;AACf,aAAa,OAAO;AACpB;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,EAAE;AACf;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;ACjSa;;AAEb;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,mEAAc;AAC1B;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,wBAAwB;AACnC;AACA;AACA;;;AAGA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,mBAAmB;AAC3B;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,WAAW;AACX;AACA;AACA;AACA;AACA,iEAAiE,EAAE;AACnE;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP,+DAA+D,EAAE;AACjE;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,iEAAiE,EAAE;AACnE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP,+DAA+D,EAAE;AACjE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,EAAE;AACnE;;AAEA,oCAAoC;AACpC;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,iEAAiE,EAAE;AACnE;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,iEAAiE,EAAE;AACnE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,+DAA+D,EAAE;AACjE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,EAAE,GAAG,EAAE,UAAU;AACpE,OAAO,UAAU;AACjB,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA,E;;;;;;;;ACzNa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,yB;;;;;;;;ACzDa;;AAEb,aAAa,mBAAO,CAAC,MAAM;;AAE3B,mBAAmB,mBAAO,CAAC,oEAAe;;AAE1C,gBAAgB,mBAAO,CAAC,gEAAW;;AAEnC;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,kEAAa;;AAEzB;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,iBAAiB;AAC9B;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,OAAO;AACpB;AACA,aAAa,iBAAiB;AAC9B;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,OAAO;AACpB;AACA,aAAa,OAAO;AACpB;AACA,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,cAAc,OAAO;AACrB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,cAAc,OAAO;AACrB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,cAAc,OAAO;AACrB;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,cAAc,MAAM;AACpB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,IAAI;AAC5C;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,kEAAkE,IAAI,KAAK,MAAM;AACjF;;AAEA;AACA,WAAW;AACX,gEAAgE,IAAI,KAAK,MAAM;AAC/E;AACA,SAAS;AACT;;AAEA;AACA,gEAAgE,IAAI,KAAK,MAAM;AAC/E;;AAEA;AACA,SAAS;AACT;AACA,gEAAgE,IAAI,KAAK,MAAM;AAC/E;AACA,SAAS;AACT,gDAAgD,IAAI;AACpD;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA,6CAA6C;AAC7C;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA,kCAAkC,SAAS;AAC3C;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA,6CAA6C;AAC7C;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qDAAqD;AACrD;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC,SAAS;AACzC;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;AC5da;;AAEb;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,QAAQ;;AAEpB,0BAA0B,mBAAO,CAAC,2EAAsB;;AAExD;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,kEAAa;;AAEzB;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,oEAAe;;AAE3B;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,mEAAc;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,mDAAmD,aAAa;AAChE;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,2DAA2D,oBAAoB;AAC/E;AACA,KAAK;AACL;AACA,iDAAiD,aAAa;AAC9D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,yEAAyE,0EAA0E;AACnJ;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc,6BAA6B;AAC3C;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,6BAA6B;AAC3C;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;;AAEA;AACA,0DAA0D,KAAK;AAC/D;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,+BAA+B;AAC1C,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,mBAAmB;AAC/B;AACA;;AAEA;AACA,iEAAiE,QAAQ;AACzE;AACA;AACA;AACA;AACA,C;;;;;;;;ACvgBA,qCAAqC,mCAAmC;AAC3D;;AAEb,YAAY,mBAAO,CAAC,KAAK;;AAEzB,YAAY,mBAAO,CAAC,KAAK;;AAEzB;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,QAAQ;;AAEpB,0BAA0B,mBAAO,CAAC,2EAAsB;;AAExD;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,kEAAa;;AAEzB;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,mEAAc;;AAE1B;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,oEAAe;;AAE3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,wBAAwB;AACrC,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,cAAc,SAAS;AACvB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA,wB;;;;;;;;ACtaa;;AAEb;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,QAAQ;AACpB;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;;AAEA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uC;;;;;;;;ACpLa;;AAEb;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,mEAAc;AAC1B;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,IAAI;AAChB;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,SAAS,mBAAmB;AAC5B;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,+DAA+D,EAAE;AACjE;;AAEA;AACA;;AAEA;AACA,sCAAsC,SAAS;AAC/C;;AAEA;AACA;AACA,KAAK;AACL,6DAA6D,EAAE;AAC/D;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,kCAAkC,SAAS;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA,E;;;;;;;;ACpEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,mBAAO,CAAC,6IAAgB;;AAE9C;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;ACxGA,qCAAqC,yCAAyC;AACjE;;AAEb,qBAAqB,mBAAO,CAAC,QAAQ;;AAErC,aAAa,mBAAO,CAAC,MAAM;;AAE3B,cAAc,mBAAO,CAAC,OAAO;;AAE7B,YAAY,mBAAO,CAAC,KAAK;;AAEzB,YAAY,mBAAO,CAAC,KAAK;;AAEzB;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,QAAQ;;AAEpB,kBAAkB,mBAAO,CAAC,kEAAa;;AAEvC,0BAA0B,mBAAO,CAAC,2EAAsB;;AAExD,oBAAoB,mBAAO,CAAC,oEAAe;;AAE3C,kBAAkB,mBAAO,CAAC,kEAAa;;AAEvC;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,kEAAa;;AAEzB,iCAAiC,GAAG;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,iBAAiB;AAC9B;AACA,aAAa,OAAO;AACpB,aAAa,2BAA2B;AACxC;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;;AAEA,kDAAkD;AAClD;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC,cAAc,QAAQ;AACtB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC,aAAa,wBAAwB;AACrC;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA,+BAA+B,kDAAkD;AACjF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,IAAI;AACjB,aAAa,qBAAqB;AAClC,aAAa,wBAAwB;AACrC;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,cAAc,MAAM;AACpB;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+HAA+H,OAAO;AACtI;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,gDAAgD,MAAM;AACtD;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,0BAA0B;AACrC,YAAY,SAAS;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,KAAK,GAAG,wBAAwB,yCAAyC,EAAE,IAAI,WAAW;AACvH;;AAEA;AACA;AACA,C;;;;;;;;ACxbA,qCAAqC,oCAAoC;AAC5D;;AAEb,qBAAqB,mBAAO,CAAC,QAAQ;;AAErC,cAAc,mBAAO,CAAC,OAAO;;AAE7B,aAAa,mBAAO,CAAC,MAAM;;AAE3B,YAAY,mBAAO,CAAC,KAAK;;AAEzB,YAAY,mBAAO,CAAC,KAAK;;AAEzB;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,QAAQ;;AAEpB;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,QAAQ;;AAEpB;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,KAAK;;AAEjB,0BAA0B,mBAAO,CAAC,2EAAsB;;AAExD,iBAAiB,mBAAO,CAAC,iEAAY;;AAErC,eAAe,mBAAO,CAAC,+DAAU;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,kEAAa;;AAEzB;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,qEAAgB;;AAE5B;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,kEAAa;;AAEzB;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,oEAAe;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,kBAAkB;AAC/B,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;;;AAGA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;;;AAGA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;;;AAGA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;;;AAGA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wBAAwB;AACrC;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK,EAAE;AACP;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;;AAGA;AACA;AACA;AACA,CAAC;AACD;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,GAAG;AACH,CAAC,EAAE;AACH;AACA;AACA;;AAEA;AACA,kDAAkD,OAAO;AACzD;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,aAAa;AACxB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA,WAAW,iBAAiB;AAC5B;AACA,WAAW,OAAO;AAClB;AACA,WAAW,QAAQ;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D,qBAAqB,6BAA6B,4BAA4B;AACxI;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL,4CAA4C,QAAQ;AACpD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2GAA2G;AAC3G;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,mBAAmB,mBAAmB,GAAG,mBAAmB;AAC5D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,oEAAoE,eAAe;AACnF;AACA,GAAG;AACH;AACA,mCAAmC;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,WAAW;AACvB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,cAAc;AAC1B;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,2CAA2C;AACtD;AACA,WAAW,OAAO;AAClB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,EAAE;AACb,WAAW,SAAS;AACpB;AACA;;;AAGA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;;AAEA,sEAAsE;AACtE;;AAEA;AACA,+DAA+D,qBAAqB,SAAS,kCAAkC;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;;;AAGA;AACA;;AAEA;AACA,2DAA2D;AAC3D;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC,WAAW,QAAQ;AACnB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;ACxmCA;;AAEA;AACA;AACA;AACA;AACA,cAAc,mBAAO,CAAC,mCAAO;AAC7B,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,E;;;;;;;ACnBA,UAAU,mBAAO,CAAC,KAAK;;AAEvB;;AAEA,WAAW,mBAAO,CAAC,MAAM;;AAEzB,YAAY,mBAAO,CAAC,OAAO;;AAE3B,eAAe,sCAA0B;;AAEzC,aAAa,mBAAO,CAAC,QAAQ;;AAE7B,YAAY,mBAAO,CAAC,0CAAS,EAAE;;;AAG/B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE;;AAEH;AACA;AACA;AACA,0FAA0F;;AAE1F;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA,GAAG;;;AAGH;;AAEA;AACA;AACA,IAAI;;;AAGJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,EAAE;;;AAGF;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA,GAAG;;;AAGH;AACA;AACA,GAAG;AACH;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA,CAAC,EAAE;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA,GAAG;;;AAGH;AACA,+CAA+C;;AAE/C;;AAEA,iBAAiB,mBAAmB;AACpC;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,EAAE;;;AAGF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA,uCAAuC;;AAEvC,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA,KAAK;;;AAGL,oFAAoF;;AAEpF;AACA;AACA;AACA;AACA,KAAK,GAAG;;AAER;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,mDAAmD;;AAEnD;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,KAAK;;;AAGL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH,sCAAsC;AACtC;AACA;AACA,oCAAoC;;AAEpC;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA,0EAA0E;;AAE1E;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;;AAGP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA,CAAC;AACD,mBAAmB,Q;;;;;;;;AC1kBN;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,C;;;;;;;AClLA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;;AAGA,cAAc;AACd;AACA;;AAEA,mCAAmC,OAAO;AAC1C;AACA;AACA;;AAEA;AACA,E;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG,IAAI,GAAG,IAAI,SAAS,IAAI;AACjI;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oEAAoE;AACpE;;AAEA;AACA,cAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oEAAoE;AACpE,8EAA8E;AAC9E;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,IAAI;AACrB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7DgC;AACA;;AAEhC,cAAc,GAAW,yBAAyB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,gBAAgB;;AAEhB;AACA,wDAAwD;;AAExD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;;AAGL;AACA,UAAU,QAAQ;AAClB,GAAG;;;AAGH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,sDAAsD;;AAEtD,+DAA+D;;AAE/D;AACA;AACA,C;;;;;AC9D2D;AAC3D,MAAM,6BAAc,GAAG,cAA4B,IAAI,8BAAoB;AAC3E,qDAAe,6BAAc,E;;ACF7B,iDAAe,MAAM,E;;ACAoB;AAClC;AACP;AACA;AACA;AACA;;AAEA;AACA,GAAG,IAAI;AACP,CAAC;;AAED;AACA;AACO;AACP;AACA,+CAA+C,UAAU;AACzD,mDAAmD,UAAU;AAC7D,GAAG;AACH,uCAAuC,UAAU;AACjD,2CAA2C,UAAU;AACrD;AACA,C;;;;ACrBA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;;AChB4C;;AAE5C;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,GAAG;;;AAGH,kBAAkB,YAAY;AAC9B;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,EAAE;;;AAGF;AACA;AACA;;AAEA,uDAAe,YAAY,E;;AC9BuC;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,oBAAoB;AAC3B,WAAW,YAAY;AACvB;;AAEA;AACA,UAAU,oBAAoB;AAC9B;AACA,GAAG;AACH,UAAU,oBAAoB;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA;;AAEA,uDAAe,YAAY,E;;ACzDkB;AACA;AAC7C,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gBAAY;AAChB;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA,iBAAiB,2BAA2B;AAC5C,0BAA0B,gBAAY;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEO;;;ACrCyC;AACO;AACL;AAClB;;AAEhC,MAAM,eAAK,GAAG,GAAW,+BAA+B;;AAEjD,wBAAwB,gCAAO;AACtC;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,IAAI,qBAAqB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,UAAU;AACxB;AACA;;;AAGA;AACA,+BAA+B;;AAE/B,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA,MAAM,eAAK;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;;AAGA;AACA,mBAAmB,gBAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,C;;;;;;ACrI4C;AACZ;;AAEN;AACI;AACkC;AAChE,MAAM,aAAK,GAAG,GAAW,6BAA6B;;AAE/C,sBAAsB,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;;AAEA;AACA,MAAM,aAAK;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA,QAAQ,aAAK;AACb;AACA;AACA,UAAU,aAAK;AACf;AACA,SAAS;AACT;;AAEA;AACA,QAAQ,aAAK;AACb;AACA;AACA,UAAU,aAAK;AACf;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,IAAI,aAAK;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,IAAI,aAAK;;AAET;AACA;AACA;AACA;AACA,OAAO;;;AAGP;AACA;AACA;AACA,OAAO;;;AAGP;AACA,MAAM;;;AAGN,IAAI,aAAa,iDAAiD;;AAElE;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,QAAQ,aAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,MAAM,aAAK;AACX;AACA;AACA,OAAO;AACP;;AAEA;AACA,MAAM,aAAK;AACX;AACA,KAAK;AACL;AACA;AACA,MAAM,aAAK;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;AACA,IAAI,aAAa;AACjB;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA,wCAAwC,KAAK;AAC7C;;AAEA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;;AAEA,yBAAyB,cAAc;AACvC;AACA;AACA;;AAEA,C;;ACxMA;AACiD;AACjB;;AAEU;AACe;AACF;AAChB;AACvC,MAAM,iBAAK,GAAG,GAAW,iCAAiC;;AAE1D;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB,cAAc;AAChC;AACA,GAAG;AACH;AACA,CAAC;;AAEM,kBAAkB,OAAO;AAChC;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;;AAGA,mBAAmB;AACnB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,IAAI,iBAAK;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACO,sBAAsB,gCAAO;AACpC;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,IAAI,qBAAqB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,+BAA+B,cAAc;;AAE7C;AACA,MAAM,iBAAK;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,2DAA2D;AAC3D,SAAS;AACT;;AAEA;AACA;AACA,OAAO,aAAa;;;AAGpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA,MAAM,iBAAK;AACX;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,6CAA6C,UAAU;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACtToD;AACX;AACJ;AACM;AACa;;AAEuB;AAC/E,8CAAe,SAAS,EAAC;;;ACPL;AACb,kBAAkB,OAAE;AACpB;AACA;AACA,kC;;ACJqC;AACd;AACJ;AACQ;AACyE;AAC3E;;AAEgB;AAChD,MAAM,eAAK,GAAG,GAAW,+BAA+B;AACxD;;AAEA;AACO,iBAAiB,SAAS;AACjC;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C;;AAE1C,mCAAmC,GAAG,IAAI;;AAE1C;AACA;AACA;;AAEA;AACA,gBAAgB,qBAAqB,qCAAqC,SAAS,uBAAuB,SAAS,YAAY,SAAS;AACxI,KAAK;AACL;AACA;;AAEA,mDAAmD,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;;;AAGA;AACA,0BAA0B;AAC1B;;AAEA,mBAAmB,oBAAoB;AACvC;AACA;AACA,MAAM,gBAAY;AAClB;AACA;;AAEA,aAAa,qBAAqB;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;AAGA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,UAAU,eAAK;AACf;;AAEA;AACA;AACA;AACA,UAAU,QAAQ;AAClB;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA,KAAK;;;AAGL;AACA,wCAAwC,KAAK;AAC7C,KAAK;;;AAGL;AACA;AACA;;AAEA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;;;AAGA;AACA,aAAa,SAAS,wBAAwB,SAAS;AACvD;;AAEA,C;;ACvMuC;AACH;AAC7B;AACP,aAAa,EAAE;AACf,WAAW,GAAG;AACd,E;;ACLmD;AACD;AACpB;AACE;AACA;;AAEuB;AACX;AAC5C,MAAM,YAAK,GAAG,GAAW,4BAA4B;;AAE9C,qBAAqB,gCAAO;AACnC;AACA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB;AACA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;;AAEA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA,KAAK;AACL,sBAAsB,QAAQ;AAC9B;;AAEA,IAAI,qBAAqB;AACzB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,0BAA0B;AAC1B;AACA,KAAK;AACL;;AAEA;AACA,wBAAwB,cAAc;AACtC,KAAK;;;AAGL;AACA;AACA;AACA,4BAA4B;;AAE5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;;AAGA;AACA,IAAI,YAAK;AACT,yCAAyC;;AAEzC,gBAAgB,QAAQ,CAAC;;AAEzB,2BAA2B;;AAE3B;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,YAAK;AACT,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;;AAEA,gCAAgC;;AAEhC;AACA;AACA,KAAK;AACL,MAAM,YAAK;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,IAAI,YAAK;;AAET;AACA,MAAM,YAAK;AACX;AACA,KAAK;;;AAGL,+BAA+B;;AAE/B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;;AAGA;AACA,IAAI,YAAK;AACT;AACA;AACA;;AAEA;AACA;AACA,MAAM,YAAK;AACX;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,UAAU,YAAK;AACf;AACA;AACA;AACA;AACA,UAAU,YAAK;AACf;AACA;AACA;AACA,YAAY,YAAK;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,UAAU,YAAK;AACf,+CAA+C;;AAE/C;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA,qDAAqD;;AAErD;AACA;AACA,MAAM,YAAK;AACX;AACA;;AAEA;AACA;AACA,KAAK;;;AAGL;AACA;AACA,KAAK;;;AAGL;AACA;AACA,QAAQ,YAAK;AACb;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,IAAI,YAAK;AACT;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA,MAAM,YAAK;AACX;AACA;;AAEA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,MAAM,YAAK;AACX,0CAA0C;;AAE1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD;;AAEhD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,MAAM,YAAK;AACX;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,mDAAmD;AACnD;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,MAAM,YAAK;AACX,4CAA4C;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,MAAM,YAAK;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,IAAI,YAAK;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,MAAM,YAAK,2CAA2C;;AAEtD,iDAAiD;;AAEjD,iDAAiD;;AAEjD,6BAA6B;;AAE7B;;AAEA;AACA;AACA,OAAO;;;AAGP,iCAAiC;;AAEjC,qBAAqB;;AAErB,+CAA+C;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,UAAU,OAAO;AACjB;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,QAAQ;;AAE1B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,C;;AC/mBqC;AACnB;AACX,MAAM,kBAAQ,GAAG,eAAe;AACI;AACQ;;;ACJnD;;AAEA;AACA;AACA;;AAEA,MAAM,kBAAQ;AACd,oFAAoF,kBAAQ;AAC5F,oFAAoF,kBAAQ;AAC5F;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,C;;AChD0C;AAC1C;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,MAAM,QAAQ;AACd;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,YAAY,OAAO;AACnB;AACA;;;AAGO;AACP;AACA,iCAAiC;;AAEjC;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B;AAC7B,GAAG;AACH,mBAAmB,iBAAiB;AACpC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,C;;ACzFuD;AACY;AACd;AACrB;;AAEhC,MAAM,eAAK,GAAG,GAAW,qBAAqB;;AAE9C;AACA;AACA;AACA;AACA;;AAEO,MAAM,wBAAQ;AACd;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;;;AAGO;AACP;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA,IAAI,eAAK;;AAET;AACA,UAAU,SAAS;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA,KAAK;;;AAGL;AACA;AACA,KAAK;;;AAGL;AACA;AACA;;AAEA,IAAI,eAAK;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA,0BAA0B;;AAE1B,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;;AAEO,sBAAsB,gCAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,6DAA6D;;AAE7D;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK,UAAU,QAAQ;AACvB;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;;;AAGA;AACA,cAAc;;AAEd;AACA;AACA;;AAEA;AACA;AACA,KAAK;;;AAGL;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;;AAGL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;;;AAGL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;;AAGL;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,IAAI,eAAK;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,oBAAoB;AAChC;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC,cAAc,cAAc;AAC5B;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,C;;ACjUO;AACP;AACA;AACA;AACA;AACA,C;;ACL8C;AACjB;AAC0B;AACvB;;AAEhC,MAAM,sBAAK,GAAG,GAAW,4BAA4B;;AAErD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM,MAAM,aAAM,SAAS,gCAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,iBAAiB,EAAE,sCAAsC,EAAE,0CAA0C,EAAE,wCAAwC,EAAE;AACjJ;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,kDAAkD;;AAElD;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA,4DAA4D;;AAE5D;AACA;AACA,MAAM,sBAAK;AACX;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM,sBAAK;AACX,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;;AAEA,qBAAqB,4BAA4B;AACjD;AACA,UAAU,sBAAK;AACf;AACA;AACA;;AAEA,MAAM,sBAAK;AACX;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,IAAI,sBAAK;;AAET;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA,cAAc,kBAAkB;AAChC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,IAAI,sBAAK;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA,WAAW,gBAAgB;AAC3B;AACA;;AAEA,WAAW,uBAAuB;AAClC;AACA;;AAEA,WAAW,cAAc;AACzB;AACA;;AAEA,WAAW,qBAAqB;AAChC;AACA;;AAEA,WAAW,qBAAqB;AAChC;AACA;;AAEA,WAAW,wBAAwB;AACnC;AACA,mDAAmD;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,IAAI,sBAAK;;AAET;AACA,MAAM,sBAAK;AACX;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,sBAAK;AACX;AACA,cAAc,cAAc;AAC5B;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,MAAM,sBAAK;AACX;AACA;AACA,KAAK;AACL,MAAM,sBAAK;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,IAAI,sBAAK;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,IAAI,sBAAK;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,MAAM,sBAAK;AACX;AACA,cAAc,qBAAqB;AACnC,OAAO;AACP,KAAK;;;AAGL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,C;;;;AC5kB2E;AACtC;AACM;AACd;AACA;AAC0B;AACvB;;AAEhC,MAAM,aAAK,GAAG,GAAW,6BAA6B;;AAE/C,sBAAsB,gCAAO;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,qBAAqB;AACzB;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAO;AAC9B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,mCAAmC,+BAAM;;AAEzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;;;AAGA;AACA,IAAI,aAAK;AACT;AACA,IAAI,aAAK;AACT,sBAAsB,MAAM;AAC5B;AACA;AACA;AACA,+BAA+B;;AAE/B,2BAA2B,EAAE;AAC7B;AACA;AACA,KAAK,EAAE;;AAEP,qBAAqB,EAAE;AACvB,MAAM,aAAK;AACX;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,MAAM,aAAK;;AAEX;AACA,yBAAyB;AACzB,OAAO;;;AAGP;AACA,QAAQ,aAAK;AACb;AACA,uBAAuB;;AAEvB;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,IAAI,aAAK,SAAS;;AAElB,mBAAmB;;AAEnB;AACA,8BAA8B;;AAE9B;AACA,mBAAmB,EAAE,0CAA0C,EAAE,0CAA0C,EAAE,4CAA4C,EAAE,4CAA4C,EAAE;AACzM;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,IAAI,aAAK;AACT;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;;AAGA;AACA;;AAEA;AACA,mBAAmB,aAAM;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,QAAQ,aAAK;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,IAAI,aAAK;AACT;;AAEA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,IAAI,aAAK;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,IAAI,aAAK;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,IAAI,aAAK;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,MAAM,aAAK;AACX;AACA;AACA;AACA,KAAK;AACL;AACA,MAAM,aAAK;AACX;AACA;AACA;AACA,QAAQ,aAAK;AACb,sEAAsE;;AAEtE;AACA;AACA;AACA,YAAY,aAAK;AACjB;AACA;AACA;AACA,WAAW;AACX,YAAY,aAAK;AACjB;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA,C;;ACna+B;AACQ;AACF;AACL;;AAEhC,MAAM,qBAAK,GAAG,GAAW,qBAAqB;;AAE9C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,GAAG;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,qBAAK;AACT,aAAa,OAAO;AACpB,GAAG;AACH;AACA,MAAM,qBAAK;AACX,sBAAsB,OAAO;AAC7B;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;AACD;;;AAGA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAE4C;AAC5C;AACA;AACA;AACA;AACA;;;;;;;;;;AClEa;;AAEb,WAAW,mBAAO,CAAC,IAAI;;AAEvB,gBAAgB,mBAAO,CAAC,kCAAU;;AAElC;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mCAAmC,GAAG;AACtC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,E;;;;;;;AC5HA,SAAS,mBAAO,CAAC,2BAAM;;AAEvB,SAAS,mBAAO,CAAC,2BAAM;;AAEvB;AACA;AACA;AACA,sB;;;;;;;ACPA;AACA;AACA;AACA;AACA;;AAEA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;AACA,sBAAsB;;AAEtB;AACA;;AAEA,6B;;;;;;;ACjBA;AACA;AACA,aAAa,mBAAO,CAAC,QAAQ;;AAE7B;AACA;AACA,E;;;;;;;ACNA,UAAU,mBAAO,CAAC,gCAAW;;AAE7B,kBAAkB,mBAAO,CAAC,wCAAmB,EAAE;AAC/C;AACA;AACA;;;AAGA;;AAEA,cAAc;;;AAGd;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA,iFAAiF;AACjF;;AAEA,2EAA2E;;AAE3E,6DAA6D;;AAE7D;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;;AAEvB,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA,sBAAsB;;AAEtB,mCAAmC;;AAEnC,6BAA6B;;AAE7B,iCAAiC;;AAEjC,2BAA2B;;AAE3B,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;;AAEA,oB;;;;;;;AChGA,UAAU,mBAAO,CAAC,gCAAW;;AAE7B,kBAAkB,mBAAO,CAAC,wCAAmB;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sDAAsD;;AAEtD;AACA,kCAAkC;;AAElC;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA,oB;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,mBAAO,CAAC,IAAI;;AAErB,UAAU,mBAAO,CAAC,KAAK;;AAEvB,YAAY,0CAA8B;AAC1C;AACA;AACA;;;AAGA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,8BAA8B;AACpE;AACA,WAAW,OAAO;AAClB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,aAAa,mBAAO,CAAC,MAAM;;AAE3B,cAAc,mBAAO,CAAC,OAAO,EAAE;;;AAG/B;AACA,eAAe;;AAEf,oBAAoB;AACpB;;AAEA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;;AAEA,gVAAgV;;AAEhV,8DAA8D;;AAE9D,uBAAuB;;AAEvB;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC;;AAEhC,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,KAAK;AACL;;;AAGA,4CAA4C;;AAE5C,4DAA4D;;AAE5D;;AAEA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;;AAGL;AACA;AACA,KAAK;AACL;;AAEA;AACA,8CAA8C;AAC9C;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL,sBAAsB;;AAEtB;AACA;AACA,yDAAyD;;AAEzD,sBAAsB;;AAEtB,6CAA6C;;AAE7C;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA,4CAA4C;;AAE5C,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;;AAGX;AACA,wBAAwB;;AAExB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;;AAGX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,QAAQ;;;AAGR;AACA;AACA,QAAQ;;;AAGR;;AAEA;AACA;AACA;AACA,SAAS;AACT,OAAO;;;AAGP;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,6CAA6C;;AAE7C,iGAAiG,0DAA0D,mDAAmD,2BAA2B,sDAAsD,kCAAkC,0CAA0C,6BAA6B,MAAM,EAAE,oCAAoC,+HAA+H,uCAAuC,MAAM,EAAE,2CAA2C,2GAA2G,uCAAuC,MAAM,EAAE,MAAM,+BAA+B,2GAA2G,uCAAuC,MAAM,EAAE,yFAAyF,qBAAqB,EAAE;;AAEtlC;AACA;;AAEA,uCAAuC;AACvC;;AAEA,+DAA+D;;AAE/D,2BAA2B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,OAAO,EAAE;AACT;;AAEA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA,SAAS,EAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,mCAAmC;AACzE,+BAA+B;;AAE/B;AACA;AACA;AACA;;AAEA,C;;;;;;;;AC1mBa;;AAEb;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;;;AAGA;AACA;;AAEA,aAAa,gBAAgB;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;;AAGA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;;AAGA,MAAM,YAAY,2BAA2B;AAC7C;AACA;;;AAGA;AACA;AACA,uB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpEA;A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","file":"737.index.js","sourcesContent":["/**\n * Expose `Emitter`.\n */\nexports.Emitter = Emitter;\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n}\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n\n  return obj;\n}\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\n\nEmitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {\n  this._callbacks = this._callbacks || {};\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);\n  return this;\n};\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\n\nEmitter.prototype.once = function (event, fn) {\n  function on() {\n    this.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\n\nEmitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {\n  this._callbacks = this._callbacks || {}; // all\n\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  } // specific event\n\n\n  var callbacks = this._callbacks['$' + event];\n  if (!callbacks) return this; // remove all handlers\n\n  if (1 == arguments.length) {\n    delete this._callbacks['$' + event];\n    return this;\n  } // remove specific handler\n\n\n  var cb;\n\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  } // Remove event specific arrays for event types that no\n  // one is subscribed for to avoid memory leak.\n\n\n  if (callbacks.length === 0) {\n    delete this._callbacks['$' + event];\n  }\n\n  return this;\n};\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\n\nEmitter.prototype.emit = function (event) {\n  this._callbacks = this._callbacks || {};\n  var args = new Array(arguments.length - 1),\n      callbacks = this._callbacks['$' + event];\n\n  for (var i = 1; i < arguments.length; i++) {\n    args[i - 1] = arguments[i];\n  }\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n}; // alias used for reserved events (protected method)\n\n\nEmitter.prototype.emitReserved = Emitter.prototype.emit;\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function (event) {\n  this._callbacks = this._callbacks || {};\n  return this._callbacks['$' + event] || [];\n};\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\n\nEmitter.prototype.hasListeners = function (event) {\n  return !!this.listeners(event).length;\n};","module.exports = require('./lib/axios');","'use strict';\n\nvar utils = require('./../utils');\n\nvar settle = require('./../core/settle');\n\nvar buildFullPath = require('../core/buildFullPath');\n\nvar buildURL = require('./../helpers/buildURL');\n\nvar http = require('http');\n\nvar https = require('https');\n\nvar httpFollow = require('follow-redirects').http;\n\nvar httpsFollow = require('follow-redirects').https;\n\nvar url = require('url');\n\nvar zlib = require('zlib');\n\nvar VERSION = require('./../env/data').version;\n\nvar createError = require('../core/createError');\n\nvar enhanceError = require('../core/enhanceError');\n\nvar defaults = require('../defaults');\n\nvar Cancel = require('../cancel/Cancel');\n\nvar isHttps = /https:?/;\n/**\n *\n * @param {http.ClientRequestArgs} options\n * @param {AxiosProxyConfig} proxy\n * @param {string} location\n */\n\nfunction setProxy(options, proxy, location) {\n  options.hostname = proxy.host;\n  options.host = proxy.host;\n  options.port = proxy.port;\n  options.path = location; // Basic proxy authorization\n\n  if (proxy.auth) {\n    var base64 = Buffer.from(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');\n    options.headers['Proxy-Authorization'] = 'Basic ' + base64;\n  } // If a proxy is used, any redirects must also pass through the proxy\n\n\n  options.beforeRedirect = function beforeRedirect(redirection) {\n    redirection.headers.host = redirection.host;\n    setProxy(redirection, proxy, redirection.href);\n  };\n}\n/*eslint consistent-return:0*/\n\n\nmodule.exports = function httpAdapter(config) {\n  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {\n    var onCanceled;\n\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n\n    var resolve = function resolve(value) {\n      done();\n      resolvePromise(value);\n    };\n\n    var rejected = false;\n\n    var reject = function reject(value) {\n      done();\n      rejected = true;\n      rejectPromise(value);\n    };\n\n    var data = config.data;\n    var headers = config.headers;\n    var headerNames = {};\n    Object.keys(headers).forEach(function storeLowerName(name) {\n      headerNames[name.toLowerCase()] = name;\n    }); // Set User-Agent (required by some servers)\n    // See https://github.com/axios/axios/issues/69\n\n    if ('user-agent' in headerNames) {\n      // User-Agent is specified; handle case where no UA header is desired\n      if (!headers[headerNames['user-agent']]) {\n        delete headers[headerNames['user-agent']];\n      } // Otherwise, use specified value\n\n    } else {\n      // Only set header if it hasn't been set in config\n      headers['User-Agent'] = 'axios/' + VERSION;\n    }\n\n    if (data && !utils.isStream(data)) {\n      if (Buffer.isBuffer(data)) {// Nothing to do...\n      } else if (utils.isArrayBuffer(data)) {\n        data = Buffer.from(new Uint8Array(data));\n      } else if (utils.isString(data)) {\n        data = Buffer.from(data, 'utf-8');\n      } else {\n        return reject(createError('Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream', config));\n      }\n\n      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {\n        return reject(createError('Request body larger than maxBodyLength limit', config));\n      } // Add Content-Length header if data exists\n\n\n      if (!headerNames['content-length']) {\n        headers['Content-Length'] = data.length;\n      }\n    } // HTTP basic authentication\n\n\n    var auth = undefined;\n\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      auth = username + ':' + password;\n    } // Parse url\n\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    var parsed = url.parse(fullPath);\n    var protocol = parsed.protocol || 'http:';\n\n    if (!auth && parsed.auth) {\n      var urlAuth = parsed.auth.split(':');\n      var urlUsername = urlAuth[0] || '';\n      var urlPassword = urlAuth[1] || '';\n      auth = urlUsername + ':' + urlPassword;\n    }\n\n    if (auth && headerNames.authorization) {\n      delete headers[headerNames.authorization];\n    }\n\n    var isHttpsRequest = isHttps.test(protocol);\n    var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\n    var options = {\n      path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\\?/, ''),\n      method: config.method.toUpperCase(),\n      headers: headers,\n      agent: agent,\n      agents: {\n        http: config.httpAgent,\n        https: config.httpsAgent\n      },\n      auth: auth\n    };\n\n    if (config.socketPath) {\n      options.socketPath = config.socketPath;\n    } else {\n      options.hostname = parsed.hostname;\n      options.port = parsed.port;\n    }\n\n    var proxy = config.proxy;\n\n    if (!proxy && proxy !== false) {\n      var proxyEnv = protocol.slice(0, -1) + '_proxy';\n      var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];\n\n      if (proxyUrl) {\n        var parsedProxyUrl = url.parse(proxyUrl);\n        var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;\n        var shouldProxy = true;\n\n        if (noProxyEnv) {\n          var noProxy = noProxyEnv.split(',').map(function trim(s) {\n            return s.trim();\n          });\n          shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {\n            if (!proxyElement) {\n              return false;\n            }\n\n            if (proxyElement === '*') {\n              return true;\n            }\n\n            if (proxyElement[0] === '.' && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {\n              return true;\n            }\n\n            return parsed.hostname === proxyElement;\n          });\n        }\n\n        if (shouldProxy) {\n          proxy = {\n            host: parsedProxyUrl.hostname,\n            port: parsedProxyUrl.port,\n            protocol: parsedProxyUrl.protocol\n          };\n\n          if (parsedProxyUrl.auth) {\n            var proxyUrlAuth = parsedProxyUrl.auth.split(':');\n            proxy.auth = {\n              username: proxyUrlAuth[0],\n              password: proxyUrlAuth[1]\n            };\n          }\n        }\n      }\n    }\n\n    if (proxy) {\n      options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');\n      setProxy(options, proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);\n    }\n\n    var transport;\n    var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);\n\n    if (config.transport) {\n      transport = config.transport;\n    } else if (config.maxRedirects === 0) {\n      transport = isHttpsProxy ? https : http;\n    } else {\n      if (config.maxRedirects) {\n        options.maxRedirects = config.maxRedirects;\n      }\n\n      transport = isHttpsProxy ? httpsFollow : httpFollow;\n    }\n\n    if (config.maxBodyLength > -1) {\n      options.maxBodyLength = config.maxBodyLength;\n    }\n\n    if (config.insecureHTTPParser) {\n      options.insecureHTTPParser = config.insecureHTTPParser;\n    } // Create the request\n\n\n    var req = transport.request(options, function handleResponse(res) {\n      if (req.aborted) return; // uncompress the response body transparently if required\n\n      var stream = res; // return the last request in case of redirects\n\n      var lastRequest = res.req || req; // if no content, is HEAD request or decompress disabled we should not decompress\n\n      if (res.statusCode !== 204 && lastRequest.method !== 'HEAD' && config.decompress !== false) {\n        switch (res.headers['content-encoding']) {\n          /*eslint default-case:0*/\n          case 'gzip':\n          case 'compress':\n          case 'deflate':\n            // add the unzipper to the body stream processing pipeline\n            stream = stream.pipe(zlib.createUnzip()); // remove the content-encoding in order to not confuse downstream operations\n\n            delete res.headers['content-encoding'];\n            break;\n        }\n      }\n\n      var response = {\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: res.headers,\n        config: config,\n        request: lastRequest\n      };\n\n      if (config.responseType === 'stream') {\n        response.data = stream;\n        settle(resolve, reject, response);\n      } else {\n        var responseBuffer = [];\n        var totalResponseBytes = 0;\n        stream.on('data', function handleStreamData(chunk) {\n          responseBuffer.push(chunk);\n          totalResponseBytes += chunk.length; // make sure the content length is not over the maxContentLength if specified\n\n          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {\n            // stream.destoy() emit aborted event before calling reject() on Node.js v16\n            rejected = true;\n            stream.destroy();\n            reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded', config, null, lastRequest));\n          }\n        });\n        stream.on('aborted', function handlerStreamAborted() {\n          if (rejected) {\n            return;\n          }\n\n          stream.destroy();\n          reject(createError('error request aborted', config, 'ERR_REQUEST_ABORTED', lastRequest));\n        });\n        stream.on('error', function handleStreamError(err) {\n          if (req.aborted) return;\n          reject(enhanceError(err, config, null, lastRequest));\n        });\n        stream.on('end', function handleStreamEnd() {\n          try {\n            var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);\n\n            if (config.responseType !== 'arraybuffer') {\n              responseData = responseData.toString(config.responseEncoding);\n\n              if (!config.responseEncoding || config.responseEncoding === 'utf8') {\n                responseData = utils.stripBOM(responseData);\n              }\n            }\n\n            response.data = responseData;\n          } catch (err) {\n            reject(enhanceError(err, config, err.code, response.request, response));\n          }\n\n          settle(resolve, reject, response);\n        });\n      }\n    }); // Handle errors\n\n    req.on('error', function handleRequestError(err) {\n      if (req.aborted && err.code !== 'ERR_FR_TOO_MANY_REDIRECTS') return;\n      reject(enhanceError(err, config, null, req));\n    }); // set tcp keep alive to prevent drop connection by peer\n\n    req.on('socket', function handleRequestSocket(socket) {\n      // default interval of sending ack packet is 1 minute\n      socket.setKeepAlive(true, 1000 * 60);\n    }); // Handle request timeout\n\n    if (config.timeout) {\n      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.\n      var timeout = parseInt(config.timeout, 10);\n\n      if (isNaN(timeout)) {\n        reject(createError('error trying to parse `config.timeout` to int', config, 'ERR_PARSE_TIMEOUT', req));\n        return;\n      } // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.\n      // And timer callback will be fired, and abort() will be invoked before connection, then get \"socket hang up\" and code ECONNRESET.\n      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.\n      // And then these socket which be hang up will devoring CPU little by little.\n      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.\n\n\n      req.setTimeout(timeout, function handleRequestTimeout() {\n        req.abort();\n        var transitional = config.transitional || defaults.transitional;\n        reject(createError('timeout of ' + timeout + 'ms exceeded', config, transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED', req));\n      });\n    }\n\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = function (cancel) {\n        if (req.aborted) return;\n        req.abort();\n        reject(!cancel || cancel && cancel.type ? new Cancel('canceled') : cancel);\n      };\n\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n      }\n    } // Send the request\n\n\n    if (utils.isStream(data)) {\n      data.on('error', function handleStreamError(err) {\n        reject(enhanceError(err, config, null, req));\n      }).pipe(req);\n    } else {\n      req.end(data);\n    }\n  });\n};","'use strict';\n\nvar utils = require('./../utils');\n\nvar settle = require('./../core/settle');\n\nvar cookies = require('./../helpers/cookies');\n\nvar buildURL = require('./../helpers/buildURL');\n\nvar buildFullPath = require('../core/buildFullPath');\n\nvar parseHeaders = require('./../helpers/parseHeaders');\n\nvar isURLSameOrigin = require('./../helpers/isURLSameOrigin');\n\nvar createError = require('../core/createError');\n\nvar defaults = require('../defaults');\n\nvar Cancel = require('../cancel/Cancel');\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n    var responseType = config.responseType;\n    var onCanceled;\n\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest(); // HTTP basic authentication\n\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true); // Set the request timeout in MS\n\n    request.timeout = config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      } // Prepare the response\n\n\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response); // Clean up request\n\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        } // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n\n\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        } // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n\n\n        setTimeout(onloadend);\n      };\n    } // Handle browser request cancellation (as opposed to a manual cancellation)\n\n\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request)); // Clean up request\n\n      request = null;\n    }; // Handle low level network errors\n\n\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request)); // Clean up request\n\n      request = null;\n    }; // Handle timeout\n\n\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n      var transitional = config.transitional || defaults.transitional;\n\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n\n      reject(createError(timeoutErrorMessage, config, transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED', request)); // Clean up request\n\n      request = null;\n    }; // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n\n\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    } // Add headers to the request\n\n\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    } // Add withCredentials to request if needed\n\n\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    } // Add responseType to request if needed\n\n\n    if (responseType && responseType !== 'json') {\n      request.responseType = config.responseType;\n    } // Handle progress if needed\n\n\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    } // Not all browsers support upload events\n\n\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = function (cancel) {\n        if (!request) {\n          return;\n        }\n\n        reject(!cancel || cancel && cancel.type ? new Cancel('canceled') : cancel);\n        request.abort();\n        request = null;\n      };\n\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    if (!requestData) {\n      requestData = null;\n    } // Send the request\n\n\n    request.send(requestData);\n  });\n};","'use strict';\n\nvar utils = require('./utils');\n\nvar bind = require('./helpers/bind');\n\nvar Axios = require('./core/Axios');\n\nvar mergeConfig = require('./core/mergeConfig');\n\nvar defaults = require('./defaults');\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\n\n\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance\n\n  utils.extend(instance, Axios.prototype, context); // Copy context to instance\n\n  utils.extend(instance, context); // Factory for creating new instances\n\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n} // Create the default instance to be exported\n\n\nvar axios = createInstance(defaults); // Expose Axios class to allow class inheritance\n\naxios.Axios = Axios; // Expose Cancel & CancelToken\n\naxios.Cancel = require('./cancel/Cancel');\naxios.CancelToken = require('./cancel/CancelToken');\naxios.isCancel = require('./cancel/isCancel');\naxios.VERSION = require('./env/data').version; // Expose all/spread\n\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\n\naxios.spread = require('./helpers/spread'); // Expose isAxiosError\n\naxios.isAxiosError = require('./helpers/isAxiosError');\nmodule.exports = axios; // Allow use of default import syntax in TypeScript\n\nmodule.exports.default = axios;","'use strict';\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\n\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\nmodule.exports = Cancel;","'use strict';\n\nvar Cancel = require('./Cancel');\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\n\n\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n  var token = this; // eslint-disable-next-line func-names\n\n  this.promise.then(function (cancel) {\n    if (!token._listeners) return;\n    var i;\n    var l = token._listeners.length;\n\n    for (i = 0; i < l; i++) {\n      token._listeners[i](cancel);\n    }\n\n    token._listeners = null;\n  }); // eslint-disable-next-line func-names\n\n  this.promise.then = function (onfulfilled) {\n    var _resolve; // eslint-disable-next-line func-names\n\n\n    var promise = new Promise(function (resolve) {\n      token.subscribe(resolve);\n      _resolve = resolve;\n    }).then(onfulfilled);\n\n    promise.cancel = function reject() {\n      token.unsubscribe(_resolve);\n    };\n\n    return promise;\n  };\n\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\n\n\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n/**\n * Subscribe to the cancel signal\n */\n\n\nCancelToken.prototype.subscribe = function subscribe(listener) {\n  if (this.reason) {\n    listener(this.reason);\n    return;\n  }\n\n  if (this._listeners) {\n    this._listeners.push(listener);\n  } else {\n    this._listeners = [listener];\n  }\n};\n/**\n * Unsubscribe from the cancel signal\n */\n\n\nCancelToken.prototype.unsubscribe = function unsubscribe(listener) {\n  if (!this._listeners) {\n    return;\n  }\n\n  var index = this._listeners.indexOf(listener);\n\n  if (index !== -1) {\n    this._listeners.splice(index, 1);\n  }\n};\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\n\n\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;","'use strict';\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};","'use strict';\n\nvar utils = require('./../utils');\n\nvar buildURL = require('../helpers/buildURL');\n\nvar InterceptorManager = require('./InterceptorManager');\n\nvar dispatchRequest = require('./dispatchRequest');\n\nvar mergeConfig = require('./mergeConfig');\n\nvar validator = require('../helpers/validator');\n\nvar validators = validator.validators;\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\n\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\n\n\nAxios.prototype.request = function request(configOrUrl, config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof configOrUrl === 'string') {\n    config = config || {};\n    config.url = configOrUrl;\n  } else {\n    config = configOrUrl || {};\n  }\n\n  if (!config.url) {\n    throw new Error('Provided config url is not valid');\n  }\n\n  config = mergeConfig(this.defaults, config); // Set config.method\n\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  var transitional = config.transitional;\n\n  if (transitional !== undefined) {\n    validator.assertOptions(transitional, {\n      silentJSONParsing: validators.transitional(validators.boolean),\n      forcedJSONParsing: validators.transitional(validators.boolean),\n      clarifyTimeoutError: validators.transitional(validators.boolean)\n    }, false);\n  } // filter out skipped interceptors\n\n\n  var requestInterceptorChain = [];\n  var synchronousRequestInterceptors = true;\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n      return;\n    }\n\n    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n  var responseInterceptorChain = [];\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n  var promise;\n\n  if (!synchronousRequestInterceptors) {\n    var chain = [dispatchRequest, undefined];\n    Array.prototype.unshift.apply(chain, requestInterceptorChain);\n    chain = chain.concat(responseInterceptorChain);\n    promise = Promise.resolve(config);\n\n    while (chain.length) {\n      promise = promise.then(chain.shift(), chain.shift());\n    }\n\n    return promise;\n  }\n\n  var newConfig = config;\n\n  while (requestInterceptorChain.length) {\n    var onFulfilled = requestInterceptorChain.shift();\n    var onRejected = requestInterceptorChain.shift();\n\n    try {\n      newConfig = onFulfilled(newConfig);\n    } catch (error) {\n      onRejected(error);\n      break;\n    }\n  }\n\n  try {\n    promise = dispatchRequest(newConfig);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n\n  while (responseInterceptorChain.length) {\n    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  if (!config.url) {\n    throw new Error('Provided config url is not valid');\n  }\n\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n}; // Provide aliases for supported request methods\n\n\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function (url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function (url, data, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\nmodule.exports = Axios;","'use strict';\n\nvar utils = require('./../utils');\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\n\n\nInterceptorManager.prototype.use = function use(fulfilled, rejected, options) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected,\n    synchronous: options ? options.synchronous : false,\n    runWhen: options ? options.runWhen : null\n  });\n  return this.handlers.length - 1;\n};\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\n\n\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\n\n\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;","'use strict';\n\nvar isAbsoluteURL = require('../helpers/isAbsoluteURL');\n\nvar combineURLs = require('../helpers/combineURLs');\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\n\n\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n\n  return requestedURL;\n};","'use strict';\n\nvar enhanceError = require('./enhanceError');\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\n\n\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};","'use strict';\n\nvar utils = require('./../utils');\n\nvar transformData = require('./transformData');\n\nvar isCancel = require('../cancel/isCancel');\n\nvar defaults = require('../defaults');\n\nvar Cancel = require('../cancel/Cancel');\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\n\n\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new Cancel('canceled');\n  }\n}\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\n\n\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config); // Ensure headers exist\n\n  config.headers = config.headers || {}; // Transform request data\n\n  config.data = transformData.call(config, config.data, config.headers, config.transformRequest); // Flatten headers\n\n  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);\n  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {\n    delete config.headers[method];\n  });\n  var adapter = config.adapter || defaults.adapter;\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config); // Transform response data\n\n    response.data = transformData.call(config, response.data, response.headers, config.transformResponse);\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config); // Transform response data\n\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};","'use strict';\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\n\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code,\n      status: this.response && this.response.status ? this.response.status : null\n    };\n  };\n\n  return error;\n};","'use strict';\n\nvar utils = require('../utils');\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\n\n\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n\n    return source;\n  } // eslint-disable-next-line consistent-return\n\n\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  } // eslint-disable-next-line consistent-return\n\n\n  function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    }\n  } // eslint-disable-next-line consistent-return\n\n\n  function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  } // eslint-disable-next-line consistent-return\n\n\n  function mergeDirectKeys(prop) {\n    if (prop in config2) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  var mergeMap = {\n    'url': valueFromConfig2,\n    'method': valueFromConfig2,\n    'data': valueFromConfig2,\n    'baseURL': defaultToConfig2,\n    'transformRequest': defaultToConfig2,\n    'transformResponse': defaultToConfig2,\n    'paramsSerializer': defaultToConfig2,\n    'timeout': defaultToConfig2,\n    'timeoutMessage': defaultToConfig2,\n    'withCredentials': defaultToConfig2,\n    'adapter': defaultToConfig2,\n    'responseType': defaultToConfig2,\n    'xsrfCookieName': defaultToConfig2,\n    'xsrfHeaderName': defaultToConfig2,\n    'onUploadProgress': defaultToConfig2,\n    'onDownloadProgress': defaultToConfig2,\n    'decompress': defaultToConfig2,\n    'maxContentLength': defaultToConfig2,\n    'maxBodyLength': defaultToConfig2,\n    'transport': defaultToConfig2,\n    'httpAgent': defaultToConfig2,\n    'httpsAgent': defaultToConfig2,\n    'cancelToken': defaultToConfig2,\n    'socketPath': defaultToConfig2,\n    'responseEncoding': defaultToConfig2,\n    'validateStatus': mergeDirectKeys\n  };\n  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {\n    var merge = mergeMap[prop] || mergeDeepProperties;\n    var configValue = merge(prop);\n    utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);\n  });\n  return config;\n};","'use strict';\n\nvar createError = require('./createError');\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\n\n\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));\n  }\n};","'use strict';\n\nvar utils = require('./../utils');\n\nvar defaults = require('./../defaults');\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\n\n\nmodule.exports = function transformData(data, headers, fns) {\n  var context = this || defaults;\n  /*eslint no-param-reassign:0*/\n\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(context, data, headers);\n  });\n  return data;\n};","'use strict';\n\nvar utils = require('./utils');\n\nvar normalizeHeaderName = require('./helpers/normalizeHeaderName');\n\nvar enhanceError = require('./core/enhanceError');\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('./adapters/xhr');\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = require('./adapters/http');\n  }\n\n  return adapter;\n}\n\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nvar defaults = {\n  transitional: {\n    silentJSONParsing: true,\n    forcedJSONParsing: true,\n    clarifyTimeoutError: false\n  },\n  adapter: getDefaultAdapter(),\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n\n    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {\n      return data;\n    }\n\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n\n    if (utils.isObject(data) || headers && headers['Content-Type'] === 'application/json') {\n      setContentTypeIfUnset(headers, 'application/json');\n      return stringifySafely(data);\n    }\n\n    return data;\n  }],\n  transformResponse: [function transformResponse(data) {\n    var transitional = this.transitional || defaults.transitional;\n    var silentJSONParsing = transitional && transitional.silentJSONParsing;\n    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';\n\n    if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw enhanceError(e, this, 'E_JSON_PARSE');\n          }\n\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n  maxContentLength: -1,\n  maxBodyLength: -1,\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*'\n    }\n  }\n};\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\nmodule.exports = defaults;","module.exports = {\n  \"version\": \"0.25.0\"\n};","'use strict';\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    return fn.apply(thisArg, args);\n  };\n};","'use strict';\n\nvar utils = require('./../utils');\n\nfunction encode(val) {\n  return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');\n}\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\n\n\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};","'use strict';\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\n\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '') : baseURL;\n};","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie\nfunction standardBrowserEnv() {\n  return {\n    write: function write(name, value, expires, path, domain, secure) {\n      var cookie = [];\n      cookie.push(name + '=' + encodeURIComponent(value));\n\n      if (utils.isNumber(expires)) {\n        cookie.push('expires=' + new Date(expires).toGMTString());\n      }\n\n      if (utils.isString(path)) {\n        cookie.push('path=' + path);\n      }\n\n      if (utils.isString(domain)) {\n        cookie.push('domain=' + domain);\n      }\n\n      if (secure === true) {\n        cookie.push('secure');\n      }\n\n      document.cookie = cookie.join('; ');\n    },\n    read: function read(name) {\n      var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n      return match ? decodeURIComponent(match[3]) : null;\n    },\n    remove: function remove(name) {\n      this.write(name, '', Date.now() - 86400000);\n    }\n  };\n}() : // Non standard browser env (web workers, react-native) lack needed support.\nfunction nonStandardBrowserEnv() {\n  return {\n    write: function write() {},\n    read: function read() {\n      return null;\n    },\n    remove: function remove() {}\n  };\n}();","'use strict';\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\n\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n};","'use strict';\n\nvar utils = require('./../utils');\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\n\n\nmodule.exports = function isAxiosError(payload) {\n  return utils.isObject(payload) && payload.isAxiosError === true;\n};","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test\n// whether the request URL is of the same origin as current location.\nfunction standardBrowserEnv() {\n  var msie = /(msie|trident)/i.test(navigator.userAgent);\n  var urlParsingNode = document.createElement('a');\n  var originURL;\n  /**\n  * Parse a URL to discover it's components\n  *\n  * @param {String} url The URL to be parsed\n  * @returns {Object}\n  */\n\n  function resolveURL(url) {\n    var href = url;\n\n    if (msie) {\n      // IE needs attribute set twice to normalize properties\n      urlParsingNode.setAttribute('href', href);\n      href = urlParsingNode.href;\n    }\n\n    urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n\n    return {\n      href: urlParsingNode.href,\n      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n      host: urlParsingNode.host,\n      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n      hostname: urlParsingNode.hostname,\n      port: urlParsingNode.port,\n      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname\n    };\n  }\n\n  originURL = resolveURL(window.location.href);\n  /**\n  * Determine if a URL shares the same origin as the current location\n  *\n  * @param {String} requestURL The URL to test\n  * @returns {boolean} True if URL shares the same origin, otherwise false\n  */\n\n  return function isURLSameOrigin(requestURL) {\n    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;\n    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;\n  };\n}() : // Non standard browser envs (web workers, react-native) lack needed support.\nfunction nonStandardBrowserEnv() {\n  return function isURLSameOrigin() {\n    return true;\n  };\n}();","'use strict';\n\nvar utils = require('../utils');\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};","'use strict';\n\nvar utils = require('./../utils'); // Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\n\n\nvar ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\n\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) {\n    return parsed;\n  }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n  return parsed;\n};","'use strict';\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\n\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};","'use strict';\n\nvar VERSION = require('../env/data').version;\n\nvar validators = {}; // eslint-disable-next-line func-names\n\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function (type, i) {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\nvar deprecatedWarnings = {};\n/**\n * Transitional option validator\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n * @returns {function}\n */\n\nvalidators.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  } // eslint-disable-next-line func-names\n\n\n  return function (value, opt, opts) {\n    if (validator === false) {\n      throw new Error(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')));\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true; // eslint-disable-next-line no-console\n\n      console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n/**\n * Assert object's properties type\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n */\n\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new TypeError('options must be an object');\n  }\n\n  var keys = Object.keys(options);\n  var i = keys.length;\n\n  while (i-- > 0) {\n    var opt = keys[i];\n    var validator = schema[opt];\n\n    if (validator) {\n      var value = options[opt];\n      var result = value === undefined || validator(value, opt, options);\n\n      if (result !== true) {\n        throw new TypeError('option ' + opt + ' must be ' + result);\n      }\n\n      continue;\n    }\n\n    if (allowUnknown !== true) {\n      throw Error('Unknown option ' + opt);\n    }\n  }\n}\n\nmodule.exports = {\n  assertOptions: assertOptions,\n  validators: validators\n};","'use strict';\n\nvar bind = require('./helpers/bind'); // utils is a library of generic helper functions non-specific to axios\n\n\nvar toString = Object.prototype.toString;\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\n\nfunction isArray(val) {\n  return Array.isArray(val);\n}\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\n\n\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\n\n\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\n\n\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\n\n\nfunction isFormData(val) {\n  return toString.call(val) === '[object FormData]';\n}\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\n\n\nfunction isArrayBufferView(val) {\n  var result;\n\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = val && val.buffer && isArrayBuffer(val.buffer);\n  }\n\n  return result;\n}\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\n\n\nfunction isString(val) {\n  return typeof val === 'string';\n}\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\n\n\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\n\n\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\n\n\nfunction isPlainObject(val) {\n  if (toString.call(val) !== '[object Object]') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\n\n\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\n\n\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\n\n\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\n\n\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\n\n\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\n\n\nfunction isURLSearchParams(val) {\n  return toString.call(val) === '[object URLSearchParams]';\n}\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\n\n\nfunction trim(str) {\n  return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n}\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\n\n\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {\n    return false;\n  }\n\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\n\n\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  } // Force an array if not already something iterable\n\n\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\n\n\nfunction merge() {\n  var result = {};\n\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n\n  return result;\n}\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\n\n\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\n\n\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n\n  return content;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM\n};","/**\n * Expose `Backoff`.\n */\nmodule.exports = Backoff;\n/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction Backoff(opts) {\n  opts = opts || {};\n  this.ms = opts.min || 100;\n  this.max = opts.max || 10000;\n  this.factor = opts.factor || 2;\n  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n  this.attempts = 0;\n}\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\n\n\nBackoff.prototype.duration = function () {\n  var ms = this.ms * Math.pow(this.factor, this.attempts++);\n\n  if (this.jitter) {\n    var rand = Math.random();\n    var deviation = Math.floor(rand * this.jitter * ms);\n    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;\n  }\n\n  return Math.min(ms, this.max) | 0;\n};\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\n\n\nBackoff.prototype.reset = function () {\n  this.attempts = 0;\n};\n/**\n * Set the minimum duration\n *\n * @api public\n */\n\n\nBackoff.prototype.setMin = function (min) {\n  this.ms = min;\n};\n/**\n * Set the maximum duration\n *\n * @api public\n */\n\n\nBackoff.prototype.setMax = function (max) {\n  this.max = max;\n};\n/**\n * Set the jitter\n *\n * @api public\n */\n\n\nBackoff.prototype.setJitter = function (jitter) {\n  this.jitter = jitter;\n};","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\nexports.destroy = (() => {\n  let warned = false;\n  return () => {\n    if (!warned) {\n      warned = true;\n      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n    }\n  };\n})();\n/**\n * Colors.\n */\n\n\nexports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n// eslint-disable-next-line complexity\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n    return true;\n  } // Internet Explorer and Edge do not support colors.\n\n\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  } // Is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\n\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\n\nfunction formatArgs(args) {\n  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\n\n  if (!this.useColors) {\n    return;\n  }\n\n  const c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit'); // The final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n\n  let index = 0;\n  let lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, match => {\n    if (match === '%%') {\n      return;\n    }\n\n    index++;\n\n    if (match === '%c') {\n      // We only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n  args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\n\n\nexports.log = console.debug || console.log || (() => {});\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\n\nfunction save(namespaces) {\n  try {\n    if (namespaces) {\n      exports.storage.setItem('debug', namespaces);\n    } else {\n      exports.storage.removeItem('debug');\n    }\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\n\nfunction load() {\n  let r;\n\n  try {\n    r = exports.storage.getItem('debug');\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  } // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\n\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\n\nfunction localstorage() {\n  try {\n    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n    // The Browser also has localStorage in the global context.\n    return localStorage;\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n\nmodule.exports = require('./common')(exports);\nconst {\n  formatters\n} = module.exports;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (error) {\n    return '[UnexpectedJSONParseError]: ' + error.message;\n  }\n};","/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\nfunction setup(env) {\n  createDebug.debug = createDebug;\n  createDebug.default = createDebug;\n  createDebug.coerce = coerce;\n  createDebug.disable = disable;\n  createDebug.enable = enable;\n  createDebug.enabled = enabled;\n  createDebug.humanize = require('ms');\n  createDebug.destroy = destroy;\n  Object.keys(env).forEach(key => {\n    createDebug[key] = env[key];\n  });\n  /**\n  * The currently active debug mode names, and names to skip.\n  */\n\n  createDebug.names = [];\n  createDebug.skips = [];\n  /**\n  * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n  *\n  * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n  */\n\n  createDebug.formatters = {};\n  /**\n  * Selects a color for a debug namespace\n  * @param {String} namespace The namespace string for the for the debug instance to be colored\n  * @return {Number|String} An ANSI color code for the given namespace\n  * @api private\n  */\n\n  function selectColor(namespace) {\n    let hash = 0;\n\n    for (let i = 0; i < namespace.length; i++) {\n      hash = (hash << 5) - hash + namespace.charCodeAt(i);\n      hash |= 0; // Convert to 32bit integer\n    }\n\n    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n  }\n\n  createDebug.selectColor = selectColor;\n  /**\n  * Create a debugger with the given `namespace`.\n  *\n  * @param {String} namespace\n  * @return {Function}\n  * @api public\n  */\n\n  function createDebug(namespace) {\n    let prevTime;\n    let enableOverride = null;\n    let namespacesCache;\n    let enabledCache;\n\n    function debug(...args) {\n      // Disabled?\n      if (!debug.enabled) {\n        return;\n      }\n\n      const self = debug; // Set `diff` timestamp\n\n      const curr = Number(new Date());\n      const ms = curr - (prevTime || curr);\n      self.diff = ms;\n      self.prev = prevTime;\n      self.curr = curr;\n      prevTime = curr;\n      args[0] = createDebug.coerce(args[0]);\n\n      if (typeof args[0] !== 'string') {\n        // Anything else let's inspect with %O\n        args.unshift('%O');\n      } // Apply any `formatters` transformations\n\n\n      let index = 0;\n      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n        // If we encounter an escaped % then don't increase the array index\n        if (match === '%%') {\n          return '%';\n        }\n\n        index++;\n        const formatter = createDebug.formatters[format];\n\n        if (typeof formatter === 'function') {\n          const val = args[index];\n          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`\n\n          args.splice(index, 1);\n          index--;\n        }\n\n        return match;\n      }); // Apply env-specific formatting (colors, etc.)\n\n      createDebug.formatArgs.call(self, args);\n      const logFn = self.log || createDebug.log;\n      logFn.apply(self, args);\n    }\n\n    debug.namespace = namespace;\n    debug.useColors = createDebug.useColors();\n    debug.color = createDebug.selectColor(namespace);\n    debug.extend = extend;\n    debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n    Object.defineProperty(debug, 'enabled', {\n      enumerable: true,\n      configurable: false,\n      get: () => {\n        if (enableOverride !== null) {\n          return enableOverride;\n        }\n\n        if (namespacesCache !== createDebug.namespaces) {\n          namespacesCache = createDebug.namespaces;\n          enabledCache = createDebug.enabled(namespace);\n        }\n\n        return enabledCache;\n      },\n      set: v => {\n        enableOverride = v;\n      }\n    }); // Env-specific initialization logic for debug instances\n\n    if (typeof createDebug.init === 'function') {\n      createDebug.init(debug);\n    }\n\n    return debug;\n  }\n\n  function extend(namespace, delimiter) {\n    const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n    newDebug.log = this.log;\n    return newDebug;\n  }\n  /**\n  * Enables a debug mode by namespaces. This can include modes\n  * separated by a colon and wildcards.\n  *\n  * @param {String} namespaces\n  * @api public\n  */\n\n\n  function enable(namespaces) {\n    createDebug.save(namespaces);\n    createDebug.namespaces = namespaces;\n    createDebug.names = [];\n    createDebug.skips = [];\n    let i;\n    const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n    const len = split.length;\n\n    for (i = 0; i < len; i++) {\n      if (!split[i]) {\n        // ignore empty strings\n        continue;\n      }\n\n      namespaces = split[i].replace(/\\*/g, '.*?');\n\n      if (namespaces[0] === '-') {\n        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n      } else {\n        createDebug.names.push(new RegExp('^' + namespaces + '$'));\n      }\n    }\n  }\n  /**\n  * Disable debug output.\n  *\n  * @return {String} namespaces\n  * @api public\n  */\n\n\n  function disable() {\n    const namespaces = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)].join(',');\n    createDebug.enable('');\n    return namespaces;\n  }\n  /**\n  * Returns true if the given mode name is enabled, false otherwise.\n  *\n  * @param {String} name\n  * @return {Boolean}\n  * @api public\n  */\n\n\n  function enabled(name) {\n    if (name[name.length - 1] === '*') {\n      return true;\n    }\n\n    let i;\n    let len;\n\n    for (i = 0, len = createDebug.skips.length; i < len; i++) {\n      if (createDebug.skips[i].test(name)) {\n        return false;\n      }\n    }\n\n    for (i = 0, len = createDebug.names.length; i < len; i++) {\n      if (createDebug.names[i].test(name)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n  * Convert regexp to namespace\n  *\n  * @param {RegExp} regxep\n  * @return {String} namespace\n  * @api private\n  */\n\n\n  function toNamespace(regexp) {\n    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, '*');\n  }\n  /**\n  * Coerce `val`.\n  *\n  * @param {Mixed} val\n  * @return {Mixed}\n  * @api private\n  */\n\n\n  function coerce(val) {\n    if (val instanceof Error) {\n      return val.stack || val.message;\n    }\n\n    return val;\n  }\n  /**\n  * XXX DO NOT USE. This is a temporary stub function.\n  * XXX It WILL be removed in the next major release.\n  */\n\n\n  function destroy() {\n    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n  }\n\n  createDebug.enable(createDebug.load());\n  return createDebug;\n}\n\nmodule.exports = setup;","/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\nif (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {\n  module.exports = require('./browser.js');\n} else {\n  module.exports = require('./node.js');\n}","/**\n * Module dependencies.\n */\nconst tty = require('tty');\n\nconst util = require('util');\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(() => {}, 'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n  // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n  // eslint-disable-next-line import/no-extraneous-dependencies\n  const supportsColor = require('supports-color');\n\n  if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n    exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];\n  }\n} catch (error) {// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n  return /^debug_/i.test(key);\n}).reduce((obj, key) => {\n  // Camel-case\n  const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {\n    return k.toUpperCase();\n  }); // Coerce string value into JS value\n\n  let val = process.env[key];\n\n  if (/^(yes|on|true|enabled)$/i.test(val)) {\n    val = true;\n  } else if (/^(no|off|false|disabled)$/i.test(val)) {\n    val = false;\n  } else if (val === 'null') {\n    val = null;\n  } else {\n    val = Number(val);\n  }\n\n  obj[prop] = val;\n  return obj;\n}, {});\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);\n}\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\n\nfunction formatArgs(args) {\n  const {\n    namespace: name,\n    useColors\n  } = this;\n\n  if (useColors) {\n    const c = this.color;\n    const colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n    const prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n  } else {\n    args[0] = getDate() + name + ' ' + args[0];\n  }\n}\n\nfunction getDate() {\n  if (exports.inspectOpts.hideDate) {\n    return '';\n  }\n\n  return new Date().toISOString() + ' ';\n}\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\n\nfunction log(...args) {\n  return process.stderr.write(util.format(...args) + '\\n');\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\n\nfunction save(namespaces) {\n  if (namespaces) {\n    process.env.DEBUG = namespaces;\n  } else {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\n\nfunction load() {\n  return process.env.DEBUG;\n}\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\n\nfunction init(debug) {\n  debug.inspectOpts = {};\n  const keys = Object.keys(exports.inspectOpts);\n\n  for (let i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\nmodule.exports = require('./common')(exports);\nconst {\n  formatters\n} = module.exports;\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts).split('\\n').map(str => str.trim()).join(' ');\n};\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\n\nformatters.O = function (v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};","'use strict';\n\nconst {\n  EMPTY_BUFFER\n} = require('./constants');\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\n\n\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n\n  if (offset < totalLength) return target.slice(0, offset);\n  return target;\n}\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\n\n\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\n\n\nfunction _unmask(buffer, mask) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\n\n\nfunction toArrayBuffer(buf) {\n  if (buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\n\n\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n  if (Buffer.isBuffer(data)) return data;\n  let buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = Buffer.from(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\ntry {\n  const bufferUtil = require('bufferutil');\n\n  module.exports = {\n    concat,\n\n    mask(source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);else bufferUtil.mask(source, mask, output, offset, length);\n    },\n\n    toArrayBuffer,\n    toBuffer,\n\n    unmask(buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);else bufferUtil.unmask(buffer, mask);\n    }\n\n  };\n} catch (e)\n/* istanbul ignore next */\n{\n  module.exports = {\n    concat,\n    mask: _mask,\n    toArrayBuffer,\n    toBuffer,\n    unmask: _unmask\n  };\n}","'use strict';\n\nmodule.exports = {\n  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],\n  EMPTY_BUFFER: Buffer.alloc(0),\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),\n  kListener: Symbol('kListener'),\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  NOOP: () => {}\n};","'use strict';\n\nconst {\n  kForOnEventAttribute,\n  kListener\n} = require('./constants');\n\nconst kCode = Symbol('kCode');\nconst kData = Symbol('kData');\nconst kError = Symbol('kError');\nconst kMessage = Symbol('kMessage');\nconst kReason = Symbol('kReason');\nconst kTarget = Symbol('kTarget');\nconst kType = Symbol('kType');\nconst kWasClean = Symbol('kWasClean');\n/**\n * Class representing an event.\n */\n\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n  /**\n   * @type {*}\n   */\n\n\n  get target() {\n    return this[kTarget];\n  }\n  /**\n   * @type {String}\n   */\n\n\n  get type() {\n    return this[kType];\n  }\n\n}\n\nObject.defineProperty(Event.prototype, 'target', {\n  enumerable: true\n});\nObject.defineProperty(Event.prototype, 'type', {\n  enumerable: true\n});\n/**\n * Class representing a close event.\n *\n * @extends Event\n */\n\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kCode] = options.code === undefined ? 0 : options.code;\n    this[kReason] = options.reason === undefined ? '' : options.reason;\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n  }\n  /**\n   * @type {Number}\n   */\n\n\n  get code() {\n    return this[kCode];\n  }\n  /**\n   * @type {String}\n   */\n\n\n  get reason() {\n    return this[kReason];\n  }\n  /**\n   * @type {Boolean}\n   */\n\n\n  get wasClean() {\n    return this[kWasClean];\n  }\n\n}\n\nObject.defineProperty(CloseEvent.prototype, 'code', {\n  enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, 'reason', {\n  enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, 'wasClean', {\n  enumerable: true\n});\n/**\n * Class representing an error event.\n *\n * @extends Event\n */\n\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kError] = options.error === undefined ? null : options.error;\n    this[kMessage] = options.message === undefined ? '' : options.message;\n  }\n  /**\n   * @type {*}\n   */\n\n\n  get error() {\n    return this[kError];\n  }\n  /**\n   * @type {String}\n   */\n\n\n  get message() {\n    return this[kMessage];\n  }\n\n}\n\nObject.defineProperty(ErrorEvent.prototype, 'error', {\n  enumerable: true\n});\nObject.defineProperty(ErrorEvent.prototype, 'message', {\n  enumerable: true\n});\n/**\n * Class representing a message event.\n *\n * @extends Event\n */\n\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kData] = options.data === undefined ? null : options.data;\n  }\n  /**\n   * @type {*}\n   */\n\n\n  get data() {\n    return this[kData];\n  }\n\n}\n\nObject.defineProperty(MessageEvent.prototype, 'data', {\n  enumerable: true\n});\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\n\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {Function} listener The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, listener, options = {}) {\n    let wrapper;\n\n    if (type === 'message') {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent('message', {\n          data: isBinary ? data : data.toString()\n        });\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'close') {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent('close', {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'error') {\n      wrapper = function onError(error) {\n        const event = new ErrorEvent('error', {\n          error,\n          message: error.message\n        });\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'open') {\n      wrapper = function onOpen() {\n        const event = new Event('open');\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else {\n      return;\n    }\n\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n    wrapper[kListener] = listener;\n\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {Function} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n\n};\nmodule.exports = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};","'use strict';\n\nconst {\n  tokenChars\n} = require('./validation');\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\n\n\nfunction push(dest, name, elem) {\n  if (dest[name] === undefined) dest[name] = [elem];else dest[name].push(elem);\n}\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\n\n\nfunction parse(header) {\n  const offers = Object.create(null);\n  let params = Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let code = -1;\n  let end = -1;\n  let i = 0;\n\n  for (; i < header.length; i++) {\n    code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (i !== 0 && (code === 0x20\n      /* ' ' */\n      || code === 0x09)\n      /* '\\t' */\n      ) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b\n      /* ';' */\n      || code === 0x2c\n      /* ',' */\n      ) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = Object.create(null);\n        } else {\n          extensionName = name;\n        }\n\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d\n      /* '=' */\n      && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (start === -1) start = i;else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22\n        /* '\"' */\n        && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c\n        /* '\\' */\n        ) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n\n        push(params, paramName, value);\n\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n\n  if (extensionName === undefined) {\n    push(offers, token, params);\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\n\n\nfunction format(extensions) {\n  return Object.keys(extensions).map(extension => {\n    let configurations = extensions[extension];\n    if (!Array.isArray(configurations)) configurations = [configurations];\n    return configurations.map(params => {\n      return [extension].concat(Object.keys(params).map(k => {\n        let values = params[k];\n        if (!Array.isArray(values)) values = [values];\n        return values.map(v => v === true ? k : `${k}=${v}`).join('; ');\n      })).join('; ');\n    }).join(', ');\n  }).join(', ');\n}\n\nmodule.exports = {\n  format,\n  parse\n};","'use strict';\n\nconst kDone = Symbol('kDone');\nconst kRun = Symbol('kRun');\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */\n\nclass Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n  /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */\n\n\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n\n\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n\n}\n\nmodule.exports = Limiter;","'use strict';\n\nconst zlib = require('zlib');\n\nconst bufferUtil = require('./buffer-util');\n\nconst Limiter = require('./limiter');\n\nconst {\n  kStatusCode\n} = require('./constants');\n\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error'); //\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\n\nlet zlibLimiter;\n/**\n * permessage-deflate implementation.\n */\n\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;\n      zlibLimiter = new Limiter(concurrency);\n    }\n  }\n  /**\n   * @type {String}\n   */\n\n\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n\n\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n\n\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n    this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);\n    return this.params;\n  }\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n\n\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n\n      this._inflate = null;\n    }\n\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n\n      this._deflate.close();\n\n      this._deflate = null;\n\n      if (callback) {\n        callback(new Error('The deflate stream was closed while data was being processed'));\n      }\n    }\n  }\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n\n\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find(params => {\n      if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === 'number' && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === 'number' && !params.client_max_window_bits) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {\n      delete accepted.client_max_window_bits;\n    }\n\n    return accepted;\n  }\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n\n\n  acceptAsClient(response) {\n    const params = response[0];\n\n    if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === 'number' && params.client_max_window_bits > this._options.clientMaxWindowBits) {\n      throw new Error('Unexpected or invalid parameter \"client_max_window_bits\"');\n    }\n\n    return params;\n  }\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n\n\n  normalizeParams(configurations) {\n    configurations.forEach(params => {\n      Object.keys(params).forEach(key => {\n        let value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n\n        value = value[0];\n\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n            }\n\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n          }\n\n          value = num;\n        } else if (key === 'client_no_context_takeover' || key === 'server_no_context_takeover') {\n          if (value !== true) {\n            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n\n        params[key] = value;\n      });\n    });\n    return configurations;\n  }\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n\n\n  decompress(data, fin, callback) {\n    zlibLimiter.add(done => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n\n\n  compress(data, fin, callback) {\n    zlibLimiter.add(done => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n\n\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._inflate = zlib.createInflateRaw({ ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n\n      this._inflate.on('error', inflateOnError);\n\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n\n    this._inflate.write(data);\n\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);\n\n      if (this._inflate._readableState.endEmitted) {\n        this._inflate.close();\n\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n          this._inflate.reset();\n        }\n      }\n\n      callback(null, data);\n    });\n  }\n  /**\n   * Compress data.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n\n\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._deflate = zlib.createDeflateRaw({ ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kCallback] = callback;\n\n    this._deflate.write(data);\n\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // The deflate stream was closed while data was being processed.\n        //\n        return;\n      }\n\n      let data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);\n      if (fin) data = data.slice(0, data.length - 4); //\n      // Ensure that the callback will not be called again in\n      // `PerMessageDeflate#cleanup()`.\n      //\n\n      this._deflate[kCallback] = null;\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.reset();\n      }\n\n      callback(null, data);\n    });\n  }\n\n}\n\nmodule.exports = PerMessageDeflate;\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\n\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\n\n\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\n\n\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}","'use strict';\n\nconst {\n  Writable\n} = require('stream');\n\nconst PerMessageDeflate = require('./permessage-deflate');\n\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = require('./constants');\n\nconst {\n  concat,\n  toArrayBuffer,\n  unmask\n} = require('./buffer-util');\n\nconst {\n  isValidStatusCode,\n  isValidUTF8\n} = require('./validation');\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */\n\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */\n  constructor(options = {}) {\n    super();\n    this._binaryType = options.binaryType || BINARY_TYPES[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket] = undefined;\n    this._bufferedBytes = 0;\n    this._buffers = [];\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n    this._state = GET_INFO;\n    this._loop = false;\n  }\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n\n\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n    this._bufferedBytes += chunk.length;\n\n    this._buffers.push(chunk);\n\n    this.startLoop(cb);\n  }\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n\n\n  consume(n) {\n    this._bufferedBytes -= n;\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = buf.slice(n);\n      return buf.slice(0, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = buf.slice(n);\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n\n\n  startLoop(cb) {\n    let err;\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          err = this.getInfo();\n          break;\n\n        case GET_PAYLOAD_LENGTH_16:\n          err = this.getPayloadLength16();\n          break;\n\n        case GET_PAYLOAD_LENGTH_64:\n          err = this.getPayloadLength64();\n          break;\n\n        case GET_MASK:\n          this.getMask();\n          break;\n\n        case GET_DATA:\n          err = this.getData(cb);\n          break;\n\n        default:\n          // `INFLATING`\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    cb(err);\n  }\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n\n\n  getInfo() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      this._loop = false;\n      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_2_3');\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      this._loop = false;\n      return error(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');\n      }\n\n      if (!this._fragmented) {\n        this._loop = false;\n        return error(RangeError, 'invalid opcode 0', true, 1002, 'WS_ERR_INVALID_OPCODE');\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        this._loop = false;\n        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, 'WS_ERR_INVALID_OPCODE');\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        this._loop = false;\n        return error(RangeError, 'FIN must be set', true, 1002, 'WS_ERR_EXPECTED_FIN');\n      }\n\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');\n      }\n\n      if (this._payloadLength > 0x7d) {\n        this._loop = false;\n        return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');\n      }\n    } else {\n      this._loop = false;\n      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, 'WS_ERR_INVALID_OPCODE');\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._isServer) {\n      if (!this._masked) {\n        this._loop = false;\n        return error(RangeError, 'MASK must be set', true, 1002, 'WS_ERR_EXPECTED_MASK');\n      }\n    } else if (this._masked) {\n      this._loop = false;\n      return error(RangeError, 'MASK must be clear', true, 1002, 'WS_ERR_UNEXPECTED_MASK');\n    }\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;else return this.haveLength();\n  }\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n\n\n  getPayloadLength16() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    return this.haveLength();\n  }\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n\n\n  getPayloadLength64() {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0); //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this._loop = false;\n      return error(RangeError, 'Unsupported WebSocket frame: payload length > 2^53 - 1', false, 1009, 'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH');\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    return this.haveLength();\n  }\n  /**\n   * Payload length has been read.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n\n\n  haveLength() {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        this._loop = false;\n        return error(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;else this._state = GET_DATA;\n  }\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n\n\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n\n\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n      if (this._masked) unmask(data, this._mask);\n    }\n\n    if (this._opcode > 0x07) return this.controlMessage(data);\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its length is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n\n      this._fragments.push(data);\n    }\n\n    return this.dataMessage();\n  }\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n\n\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          return cb(error(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'));\n        }\n\n        this._fragments.push(buf);\n      }\n\n      const er = this.dataMessage();\n      if (er) return cb(er);\n      this.startLoop(cb);\n    });\n  }\n  /**\n   * Handles a data message.\n   *\n   * @return {(Error|undefined)} A possible error\n   * @private\n   */\n\n\n  dataMessage() {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n\n      if (this._opcode === 2) {\n        let data;\n\n        if (this._binaryType === 'nodebuffer') {\n          data = concat(fragments, messageLength);\n        } else if (this._binaryType === 'arraybuffer') {\n          data = toArrayBuffer(concat(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n\n        this.emit('message', data, true);\n      } else {\n        const buf = concat(fragments, messageLength);\n\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          this._loop = false;\n          return error(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');\n        }\n\n        this.emit('message', buf, false);\n      }\n    }\n\n    this._state = GET_INFO;\n  }\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n\n\n  controlMessage(data) {\n    if (this._opcode === 0x08) {\n      this._loop = false;\n\n      if (data.length === 0) {\n        this.emit('conclude', 1005, EMPTY_BUFFER);\n        this.end();\n      } else if (data.length === 1) {\n        return error(RangeError, 'invalid payload length 1', true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!isValidStatusCode(code)) {\n          return error(RangeError, `invalid status code ${code}`, true, 1002, 'WS_ERR_INVALID_CLOSE_CODE');\n        }\n\n        const buf = data.slice(2);\n\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          return error(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');\n        }\n\n        this.emit('conclude', code, buf);\n        this.end();\n      }\n    } else if (this._opcode === 0x09) {\n      this.emit('ping', data);\n    } else {\n      this.emit('pong', data);\n    }\n\n    this._state = GET_INFO;\n  }\n\n}\n\nmodule.exports = Receiver;\n/**\n * Builds an error object.\n *\n * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n * @param {String} message The error message\n * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n *     `message`\n * @param {Number} statusCode The status code\n * @param {String} errorCode The exposed error code\n * @return {(Error|RangeError)} The error\n * @private\n */\n\nfunction error(ErrorCtor, message, prefix, statusCode, errorCode) {\n  const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);\n  Error.captureStackTrace(err, error);\n  err.code = errorCode;\n  err[kStatusCode] = statusCode;\n  return err;\n}","/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls$\" }] */\n'use strict';\n\nconst net = require('net');\n\nconst tls = require('tls');\n\nconst {\n  randomFillSync\n} = require('crypto');\n\nconst PerMessageDeflate = require('./permessage-deflate');\n\nconst {\n  EMPTY_BUFFER\n} = require('./constants');\n\nconst {\n  isValidStatusCode\n} = require('./validation');\n\nconst {\n  mask: applyMask,\n  toBuffer\n} = require('./buffer-util');\n\nconst mask = Buffer.alloc(4);\n/**\n * HyBi Sender implementation.\n */\n\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   */\n  constructor(socket, extensions) {\n    this._extensions = extensions || {};\n    this._socket = socket;\n    this._firstFragment = true;\n    this._compress = false;\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {Buffer} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {Buffer[]} The framed data as a list of `Buffer` instances\n   * @public\n   */\n\n\n  static frame(data, options) {\n    const merge = options.mask && options.readOnly;\n    let offset = options.mask ? 6 : 2;\n    let payloadLength = data.length;\n\n    if (data.length >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (data.length > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(data.length, 2);\n    } else if (payloadLength === 127) {\n      target.writeUInt32BE(0, 2);\n      target.writeUInt32BE(data.length, 6);\n    }\n\n    if (!options.mask) return [target, data];\n    randomFillSync(mask, 0, 4);\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, data.length);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, data.length);\n    return [target, data];\n  }\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n\n\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n\n      if (length > 123) {\n        throw new RangeError('The message must not be greater than 123 bytes');\n      }\n\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n\n      if (typeof data === 'string') {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doClose, buf, mask, cb]);\n    } else {\n      this.doClose(buf, mask, cb);\n    }\n  }\n  /**\n   * Frames and sends a close message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @private\n   */\n\n\n  doClose(data, mask, cb) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x08,\n      mask,\n      readOnly: false\n    }), cb);\n  }\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n\n\n  ping(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (buf.length > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPing(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n  /**\n   * Frames and sends a ping message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified\n   * @param {Function} [cb] Callback\n   * @private\n   */\n\n\n  doPing(data, mask, readOnly, cb) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x09,\n      mask,\n      readOnly\n    }), cb);\n  }\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n\n\n  pong(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (buf.length > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPong(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n  /**\n   * Frames and sends a pong message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified\n   * @param {Function} [cb] Callback\n   * @private\n   */\n\n\n  doPong(data, mask, readOnly, cb) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x0a,\n      mask,\n      readOnly\n    }), cb);\n  }\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n\n\n  send(data, options, cb) {\n    const buf = toBuffer(data);\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n\n      if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? 'server_no_context_takeover' : 'client_no_context_takeover']) {\n        rsv1 = buf.length >= perMessageDeflate._threshold;\n      }\n\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        fin: options.fin,\n        rsv1,\n        opcode,\n        mask: options.mask,\n        readOnly: toBuffer.readOnly\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, buf, this._compress, opts, cb]);\n      } else {\n        this.dispatch(buf, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(Sender.frame(buf, {\n        fin: options.fin,\n        rsv1: false,\n        opcode,\n        mask: options.mask,\n        readOnly: toBuffer.readOnly\n      }), cb);\n    }\n  }\n  /**\n   * Dispatches a data message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n\n\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    this._bufferedBytes += data.length;\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error('The socket was closed while data was being compressed');\n        if (typeof cb === 'function') cb(err);\n\n        for (let i = 0; i < this._queue.length; i++) {\n          const callback = this._queue[i][4];\n          if (typeof callback === 'function') callback(err);\n        }\n\n        return;\n      }\n\n      this._bufferedBytes -= data.length;\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n\n\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[1].length;\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n\n\n  enqueue(params) {\n    this._bufferedBytes += params[1].length;\n\n    this._queue.push(params);\n  }\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n\n\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n\n      this._socket.write(list[0]);\n\n      this._socket.write(list[1], cb);\n\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n\n}\n\nmodule.exports = Sender;","'use strict';\n\nconst {\n  Duplex\n} = require('stream');\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */\n\n\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\n\n\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */\n\n\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */\n\n\nfunction createWebSocketStream(ws, options) {\n  let resumeOnReceiverDrain = true;\n  let terminateOnDestroy = true;\n\n  function receiverOnDrain() {\n    if (resumeOnReceiverDrain) ws._socket.resume();\n  }\n\n  if (ws.readyState === ws.CONNECTING) {\n    ws.once('open', function open() {\n      ws._receiver.removeAllListeners('drain');\n\n      ws._receiver.on('drain', receiverOnDrain);\n    });\n  } else {\n    ws._receiver.removeAllListeners('drain');\n\n    ws._receiver.on('drain', receiverOnDrain);\n  }\n\n  const duplex = new Duplex({ ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n  ws.on('message', function message(msg, isBinary) {\n    const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n\n    if (!duplex.push(data)) {\n      resumeOnReceiverDrain = false;\n\n      ws._socket.pause();\n    }\n  });\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return; // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n    //\n    // - If the `'error'` event is emitted before the `'open'` event, then\n    //   `ws.terminate()` is a noop as no socket is assigned.\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\n    //   event of the `Receiver` object. The listener already closes the\n    //   connection by calling `ws.close()`. This allows a close frame to be\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\n    //   then the close frame might not be sent.\n\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n    duplex.push(null);\n  });\n\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n\n    let called = false;\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n    if (terminateOnDestroy) ws.terminate();\n  };\n\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    } // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n\n\n    if (ws._socket === null) return;\n\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n\n      ws.close();\n    }\n  };\n\n  duplex._read = function () {\n    if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {\n      resumeOnReceiverDrain = true;\n      if (!ws._receiver._writableState.needDrain) ws._socket.resume();\n    }\n  };\n\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n\n    ws.send(chunk, callback);\n  };\n\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\n\nmodule.exports = createWebSocketStream;","'use strict';\n\nconst {\n  tokenChars\n} = require('./validation');\n/**\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\n *\n * @param {String} header The field value of the header\n * @return {Set} The subprotocol names\n * @public\n */\n\n\nfunction parse(header) {\n  const protocols = new Set();\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (i; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (end === -1 && tokenChars[code] === 1) {\n      if (start === -1) start = i;\n    } else if (i !== 0 && (code === 0x20\n    /* ' ' */\n    || code === 0x09)\n    /* '\\t' */\n    ) {\n      if (end === -1 && start !== -1) end = i;\n    } else if (code === 0x2c\n    /* ',' */\n    ) {\n      if (start === -1) {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n\n      if (end === -1) end = i;\n      const protocol = header.slice(start, end);\n\n      if (protocols.has(protocol)) {\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n      }\n\n      protocols.add(protocol);\n      start = end = -1;\n    } else {\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n    }\n  }\n\n  if (start === -1 || end !== -1) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  const protocol = header.slice(start, i);\n\n  if (protocols.has(protocol)) {\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  }\n\n  protocols.add(protocol);\n  return protocols;\n}\n\nmodule.exports = {\n  parse\n};","'use strict'; //\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\n\nconst tokenChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\n\nfunction isValidStatusCode(code) {\n  return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;\n}\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\n\n\nfunction _isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n\n  while (i < len) {\n    if ((buf[i] & 0x80) === 0) {\n      // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {\n      // 110xxxxx 10xxxxxx\n      if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0 // Overlong\n      ) {\n        return false;\n      }\n\n      i += 2;\n    } else if ((buf[i] & 0xf0) === 0xe0) {\n      // 1110xxxx 10xxxxxx 10xxxxxx\n      if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 || buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0 // Surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      }\n\n      i += 3;\n    } else if ((buf[i] & 0xf8) === 0xf0) {\n      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 || buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4 // > U+10FFFF\n      ) {\n        return false;\n      }\n\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\ntry {\n  const isValidUTF8 = require('utf-8-validate');\n\n  module.exports = {\n    isValidStatusCode,\n\n    isValidUTF8(buf) {\n      return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);\n    },\n\n    tokenChars\n  };\n} catch (e)\n/* istanbul ignore next */\n{\n  module.exports = {\n    isValidStatusCode,\n    isValidUTF8: _isValidUTF8,\n    tokenChars\n  };\n}","/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls|https$\" }] */\n'use strict';\n\nconst EventEmitter = require('events');\n\nconst http = require('http');\n\nconst https = require('https');\n\nconst net = require('net');\n\nconst tls = require('tls');\n\nconst {\n  createHash\n} = require('crypto');\n\nconst extension = require('./extension');\n\nconst PerMessageDeflate = require('./permessage-deflate');\n\nconst subprotocol = require('./subprotocol');\n\nconst WebSocket = require('./websocket');\n\nconst {\n  GUID,\n  kWebSocket\n} = require('./constants');\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\n\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n    options = {\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null,\n      // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      ...options\n    };\n\n    if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {\n      throw new TypeError('One and only one of the \"port\", \"server\", or \"noServer\" options ' + 'must be specified');\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n\n      this._server.listen(options.port, options.host, options.backlog, callback);\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, 'connection');\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n\n    if (options.clientTracking) {\n      this.clients = new Set();\n      this._shouldEmitClose = false;\n    }\n\n    this.options = options;\n    this._state = RUNNING;\n  }\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n\n\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n\n\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once('close', () => {\n          cb(new Error('The server is not running'));\n        });\n      }\n\n      process.nextTick(emitClose, this);\n      return;\n    }\n\n    if (cb) this.once('close', cb);\n    if (this._state === CLOSING) return;\n    this._state = CLOSING;\n\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n\n        this._removeListeners = this._server = null;\n      }\n\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n\n      this._removeListeners();\n\n      this._removeListeners = this._server = null; //\n      // The HTTP/S server was created internally. Close it, and rely on its\n      // `'close'` event.\n      //\n\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n\n\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n\n\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n    const key = req.headers['sec-websocket-key'] !== undefined ? req.headers['sec-websocket-key'] : false;\n    const version = +req.headers['sec-websocket-version'];\n\n    if (req.method !== 'GET' || req.headers.upgrade.toLowerCase() !== 'websocket' || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {\n      return abortHandshake(socket, 400);\n    }\n\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n    let protocols = new Set();\n\n    if (secWebSocketProtocol !== undefined) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        return abortHandshake(socket, 400);\n      }\n    }\n\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n    const extensions = {};\n\n    if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {\n      const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);\n\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        return abortHandshake(socket, 400);\n      }\n    } //\n    // Optionally call external client verification handler.\n    //\n\n\n    if (this.options.verifyClient) {\n      const info = {\n        origin: req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n\n\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    if (socket[kWebSocket]) {\n      throw new Error('server.handleUpgrade() was called more than once with the same ' + 'socket, possibly due to a misconfiguration');\n    }\n\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n    const digest = createHash('sha1').update(key + GUID).digest('base64');\n    const headers = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade', `Sec-WebSocket-Accept: ${digest}`];\n    const ws = new WebSocket(null);\n\n    if (protocols.size) {\n      //\n      // Optionally call external protocol selection handler.\n      //\n      const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    } //\n    // Allow external modification/inspection of handshake headers.\n    //\n\n\n    this.emit('headers', headers, req);\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n    ws.setSocket(socket, head, {\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => {\n        this.clients.delete(ws);\n\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n\n    cb(ws, req);\n  }\n\n}\n\nmodule.exports = WebSocketServer;\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */\n\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\n\n\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\n/**\n * Handle premature socket errors.\n *\n * @private\n */\n\n\nfunction socketOnError() {\n  this.destroy();\n}\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\n\n\nfunction abortHandshake(socket, code, message, headers) {\n  if (socket.writable) {\n    message = message || http.STATUS_CODES[code];\n    headers = {\n      Connection: 'close',\n      'Content-Type': 'text/html',\n      'Content-Length': Buffer.byteLength(message),\n      ...headers\n    };\n    socket.write(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` + Object.keys(headers).map(h => `${h}: ${headers[h]}`).join('\\r\\n') + '\\r\\n\\r\\n' + message);\n  }\n\n  socket.removeListener('error', socketOnError);\n  socket.destroy();\n}","/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Readable$\" }] */\n'use strict';\n\nconst EventEmitter = require('events');\n\nconst https = require('https');\n\nconst http = require('http');\n\nconst net = require('net');\n\nconst tls = require('tls');\n\nconst {\n  randomBytes,\n  createHash\n} = require('crypto');\n\nconst {\n  Readable\n} = require('stream');\n\nconst {\n  URL\n} = require('url');\n\nconst PerMessageDeflate = require('./permessage-deflate');\n\nconst Receiver = require('./receiver');\n\nconst Sender = require('./sender');\n\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = require('./constants');\n\nconst {\n  EventTarget: {\n    addEventListener,\n    removeEventListener\n  }\n} = require('./event-target');\n\nconst {\n  format,\n  parse\n} = require('./extension');\n\nconst {\n  toBuffer\n} = require('./buffer-util');\n\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\nconst protocolVersions = [8, 13];\nconst closeTimeout = 30 * 1000;\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\n\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._extensions = {};\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n\n\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n    this._binaryType = type; //\n    // Allow to change `binaryType` on the fly.\n    //\n\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n  /**\n   * @type {Number}\n   */\n\n\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n  /**\n   * @type {String}\n   */\n\n\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n  /**\n   * @type {Function}\n   */\n\n  /* istanbul ignore next */\n\n\n  get onclose() {\n    return null;\n  }\n  /**\n   * @type {Function}\n   */\n\n  /* istanbul ignore next */\n\n\n  get onerror() {\n    return null;\n  }\n  /**\n   * @type {Function}\n   */\n\n  /* istanbul ignore next */\n\n\n  get onopen() {\n    return null;\n  }\n  /**\n   * @type {Function}\n   */\n\n  /* istanbul ignore next */\n\n\n  get onmessage() {\n    return null;\n  }\n  /**\n   * @type {String}\n   */\n\n\n  get protocol() {\n    return this._protocol;\n  }\n  /**\n   * @type {Number}\n   */\n\n\n  get readyState() {\n    return this._readyState;\n  }\n  /**\n   * @type {String}\n   */\n\n\n  get url() {\n    return this._url;\n  }\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n\n\n  setSocket(socket, head, options) {\n    const receiver = new Receiver({\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n    this._sender = new Sender(socket, this._extensions);\n    this._receiver = receiver;\n    this._socket = socket;\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n    socket.setTimeout(0);\n    socket.setNoDelay();\n    if (head.length > 0) socket.unshift(head);\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n\n\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n\n\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n        this._socket.end();\n      }\n\n      return;\n    }\n\n    this._readyState = WebSocket.CLOSING;\n\n    this._sender.close(code, data, !this._isServer, err => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n      this._closeFrameSent = true;\n\n      if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {\n        this._socket.end();\n      }\n    }); //\n    // Specify a timeout for the closing handshake to complete.\n    //\n\n\n    this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);\n  }\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n\n\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n\n\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n\n\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n\n\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n\n      this._socket.destroy();\n    }\n  }\n\n}\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\n\n\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\n\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\n\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\n\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\n\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\n\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\n\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\n\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n['binaryType', 'bufferedAmount', 'extensions', 'protocol', 'readyState', 'url'].forEach(property => {\n  Object.defineProperty(WebSocket.prototype, property, {\n    enumerable: true\n  });\n}); //\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n\n['open', 'error', 'close', 'message'].forEach(method => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n\n      return null;\n    },\n\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n\n      if (typeof handler !== 'function') return;\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n\n  });\n});\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\nmodule.exports = WebSocket;\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\n\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: undefined,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: undefined,\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(', ')})`);\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket._url = address.href;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n\n    websocket._url = address;\n  }\n\n  const isSecure = parsedUrl.protocol === 'wss:';\n  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';\n\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isUnixSocket) {\n    throw new SyntaxError('The URL\\'s protocol must be one of \"ws:\", \"wss:\", or \"ws+unix:\"');\n  }\n\n  if (isUnixSocket && !parsedUrl.pathname) {\n    throw new SyntaxError(\"The URL's pathname is empty\");\n  }\n\n  if (parsedUrl.hash) {\n    throw new SyntaxError('The URL contains a fragment identifier');\n  }\n\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const get = isSecure ? https.get : http.get;\n  const protocolSet = new Set();\n  let perMessageDeflate;\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[') ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n  opts.headers = {\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket',\n    ...opts.headers\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (typeof protocol !== 'string' || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {\n        throw new SyntaxError('An invalid or duplicated subprotocol was specified');\n      }\n\n      protocolSet.add(protocol);\n    }\n\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isUnixSocket) {\n    const parts = opts.path.split(':');\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  let req = websocket._req = get(opts);\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', err => {\n    if (req === null || req.aborted) return;\n    req = websocket._req = null;\n    websocket._readyState = WebSocket.CLOSING;\n    websocket.emit('error', err);\n    websocket.emitClose();\n  });\n  req.on('response', res => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n      const addr = new URL(location, address);\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);\n    }\n  });\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res); //\n    // The user may have closed the connection from a listener of the `upgrade`\n    // event.\n    //\n\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n    req = websocket._req = null;\n    const digest = createHash('sha1').update(key + GUID).digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    let protError;\n\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket._protocol = serverProt;\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message = 'Server sent a Sec-WebSocket-Extensions header but no extension ' + 'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      let extensions;\n\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      const extensionNames = Object.keys(extensions);\n\n      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {\n        const message = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n    }\n\n    websocket.setSocket(socket, head, {\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n}\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\n\n\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\n\n\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n\n  return tls.connect(options);\n}\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\n\n\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream.abort();\n\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n\n    stream.once('abort', websocket.emitClose.bind(websocket));\n    websocket.emit('error', err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\n\n\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length; //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n\n    if (websocket._socket) websocket._sender._bufferedBytes += length;else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);\n    cb(err);\n  }\n}\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\n\n\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n  if (websocket._socket[kWebSocket] === undefined) return;\n\n  websocket._socket.removeListener('data', socketOnData);\n\n  process.nextTick(resume, websocket._socket);\n  if (code === 1005) websocket.close();else websocket.close(code, reason);\n}\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\n\n\nfunction receiverOnDrain() {\n  this[kWebSocket]._socket.resume();\n}\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\n\n\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData); //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n\n\n    process.nextTick(resume, websocket._socket);\n    websocket.close(err[kStatusCode]);\n  }\n\n  websocket.emit('error', err);\n}\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\n\n\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\n\n\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\n\n\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n  websocket.pong(data, !websocket._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\n\n\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\n\n\nfunction resume(stream) {\n  stream.resume();\n}\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */\n\n\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n  websocket._readyState = WebSocket.CLOSING;\n  let chunk; //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n\n  if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {\n    websocket._receiver.write(chunk);\n  }\n\n  websocket._receiver.end();\n\n  this[kWebSocket] = undefined;\n  clearTimeout(websocket._closeTimer);\n\n  if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\n\n\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */\n\n\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n  websocket._readyState = WebSocket.CLOSING;\n\n  websocket._receiver.end();\n\n  this.end();\n}\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */\n\n\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}","var debug;\n\nmodule.exports = function () {\n  if (!debug) {\n    try {\n      /* eslint global-require: off */\n      debug = require(\"debug\")(\"follow-redirects\");\n    } catch (error) {\n      /* */\n    }\n\n    if (typeof debug !== \"function\") {\n      debug = function () {\n        /* */\n      };\n    }\n  }\n\n  debug.apply(null, arguments);\n};","var url = require(\"url\");\n\nvar URL = url.URL;\n\nvar http = require(\"http\");\n\nvar https = require(\"https\");\n\nvar Writable = require(\"stream\").Writable;\n\nvar assert = require(\"assert\");\n\nvar debug = require(\"./debug\"); // Create handlers that pass events from native requests\n\n\nvar events = [\"abort\", \"aborted\", \"connect\", \"error\", \"socket\", \"timeout\"];\nvar eventHandlers = Object.create(null);\nevents.forEach(function (event) {\n  eventHandlers[event] = function (arg1, arg2, arg3) {\n    this._redirectable.emit(event, arg1, arg2, arg3);\n  };\n}); // Error types with codes\n\nvar RedirectionError = createErrorType(\"ERR_FR_REDIRECTION_FAILURE\", \"Redirected request failed\");\nvar TooManyRedirectsError = createErrorType(\"ERR_FR_TOO_MANY_REDIRECTS\", \"Maximum number of redirects exceeded\");\nvar MaxBodyLengthExceededError = createErrorType(\"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\", \"Request body larger than maxBodyLength limit\");\nvar WriteAfterEndError = createErrorType(\"ERR_STREAM_WRITE_AFTER_END\", \"write after end\"); // An HTTP(S) request that can be redirected\n\nfunction RedirectableRequest(options, responseCallback) {\n  // Initialize the request\n  Writable.call(this);\n\n  this._sanitizeOptions(options);\n\n  this._options = options;\n  this._ended = false;\n  this._ending = false;\n  this._redirectCount = 0;\n  this._redirects = [];\n  this._requestBodyLength = 0;\n  this._requestBodyBuffers = []; // Attach a callback if passed\n\n  if (responseCallback) {\n    this.on(\"response\", responseCallback);\n  } // React to responses of native requests\n\n\n  var self = this;\n\n  this._onNativeResponse = function (response) {\n    self._processResponse(response);\n  }; // Perform the first request\n\n\n  this._performRequest();\n}\n\nRedirectableRequest.prototype = Object.create(Writable.prototype);\n\nRedirectableRequest.prototype.abort = function () {\n  abortRequest(this._currentRequest);\n  this.emit(\"abort\");\n}; // Writes buffered data to the current native request\n\n\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\n  // Writing is not allowed if end has been called\n  if (this._ending) {\n    throw new WriteAfterEndError();\n  } // Validate input and shift parameters if necessary\n\n\n  if (!(typeof data === \"string\" || typeof data === \"object\" && \"length\" in data)) {\n    throw new TypeError(\"data should be a string, Buffer or Uint8Array\");\n  }\n\n  if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  } // Ignore empty buffers, since writing them doesn't invoke the callback\n  // https://github.com/nodejs/node/issues/22066\n\n\n  if (data.length === 0) {\n    if (callback) {\n      callback();\n    }\n\n    return;\n  } // Only write when we don't exceed the maximum body length\n\n\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n    this._requestBodyLength += data.length;\n\n    this._requestBodyBuffers.push({\n      data: data,\n      encoding: encoding\n    });\n\n    this._currentRequest.write(data, encoding, callback);\n  } // Error when we exceed the maximum body length\n  else {\n    this.emit(\"error\", new MaxBodyLengthExceededError());\n    this.abort();\n  }\n}; // Ends the current native request\n\n\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\n  // Shift parameters if necessary\n  if (typeof data === \"function\") {\n    callback = data;\n    data = encoding = null;\n  } else if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  } // Write data if needed and end\n\n\n  if (!data) {\n    this._ended = this._ending = true;\n\n    this._currentRequest.end(null, null, callback);\n  } else {\n    var self = this;\n    var currentRequest = this._currentRequest;\n    this.write(data, encoding, function () {\n      self._ended = true;\n      currentRequest.end(null, null, callback);\n    });\n    this._ending = true;\n  }\n}; // Sets a header value on the current native request\n\n\nRedirectableRequest.prototype.setHeader = function (name, value) {\n  this._options.headers[name] = value;\n\n  this._currentRequest.setHeader(name, value);\n}; // Clears a header value on the current native request\n\n\nRedirectableRequest.prototype.removeHeader = function (name) {\n  delete this._options.headers[name];\n\n  this._currentRequest.removeHeader(name);\n}; // Global timeout for all underlying requests\n\n\nRedirectableRequest.prototype.setTimeout = function (msecs, callback) {\n  var self = this; // Destroys the socket on timeout\n\n  function destroyOnTimeout(socket) {\n    socket.setTimeout(msecs);\n    socket.removeListener(\"timeout\", socket.destroy);\n    socket.addListener(\"timeout\", socket.destroy);\n  } // Sets up a timer to trigger a timeout event\n\n\n  function startTimer(socket) {\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n    }\n\n    self._timeout = setTimeout(function () {\n      self.emit(\"timeout\");\n      clearTimer();\n    }, msecs);\n    destroyOnTimeout(socket);\n  } // Stops a timeout from triggering\n\n\n  function clearTimer() {\n    // Clear the timeout\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n      self._timeout = null;\n    } // Clean up all attached listeners\n\n\n    self.removeListener(\"abort\", clearTimer);\n    self.removeListener(\"error\", clearTimer);\n    self.removeListener(\"response\", clearTimer);\n\n    if (callback) {\n      self.removeListener(\"timeout\", callback);\n    }\n\n    if (!self.socket) {\n      self._currentRequest.removeListener(\"socket\", startTimer);\n    }\n  } // Attach callback if passed\n\n\n  if (callback) {\n    this.on(\"timeout\", callback);\n  } // Start the timer if or when the socket is opened\n\n\n  if (this.socket) {\n    startTimer(this.socket);\n  } else {\n    this._currentRequest.once(\"socket\", startTimer);\n  } // Clean up on events\n\n\n  this.on(\"socket\", destroyOnTimeout);\n  this.on(\"abort\", clearTimer);\n  this.on(\"error\", clearTimer);\n  this.on(\"response\", clearTimer);\n  return this;\n}; // Proxy all other public ClientRequest methods\n\n\n[\"flushHeaders\", \"getHeader\", \"setNoDelay\", \"setSocketKeepAlive\"].forEach(function (method) {\n  RedirectableRequest.prototype[method] = function (a, b) {\n    return this._currentRequest[method](a, b);\n  };\n}); // Proxy all public ClientRequest properties\n\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\n  Object.defineProperty(RedirectableRequest.prototype, property, {\n    get: function () {\n      return this._currentRequest[property];\n    }\n  });\n});\n\nRedirectableRequest.prototype._sanitizeOptions = function (options) {\n  // Ensure headers are always present\n  if (!options.headers) {\n    options.headers = {};\n  } // Since http.request treats host as an alias of hostname,\n  // but the url module interprets host as hostname plus port,\n  // eliminate the host property to avoid confusion.\n\n\n  if (options.host) {\n    // Use hostname if set, because it has precedence\n    if (!options.hostname) {\n      options.hostname = options.host;\n    }\n\n    delete options.host;\n  } // Complete the URL object when necessary\n\n\n  if (!options.pathname && options.path) {\n    var searchPos = options.path.indexOf(\"?\");\n\n    if (searchPos < 0) {\n      options.pathname = options.path;\n    } else {\n      options.pathname = options.path.substring(0, searchPos);\n      options.search = options.path.substring(searchPos);\n    }\n  }\n}; // Executes the next native request (initial or redirect)\n\n\nRedirectableRequest.prototype._performRequest = function () {\n  // Load the native protocol\n  var protocol = this._options.protocol;\n  var nativeProtocol = this._options.nativeProtocols[protocol];\n\n  if (!nativeProtocol) {\n    this.emit(\"error\", new TypeError(\"Unsupported protocol \" + protocol));\n    return;\n  } // If specified, use the agent corresponding to the protocol\n  // (HTTP and HTTPS use different types of agents)\n\n\n  if (this._options.agents) {\n    var scheme = protocol.substr(0, protocol.length - 1);\n    this._options.agent = this._options.agents[scheme];\n  } // Create the native request\n\n\n  var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);\n  this._currentUrl = url.format(this._options); // Set up event handlers\n\n  request._redirectable = this;\n\n  for (var e = 0; e < events.length; e++) {\n    request.on(events[e], eventHandlers[events[e]]);\n  } // End a redirected request\n  // (The first request must be ended explicitly with RedirectableRequest#end)\n\n\n  if (this._isRedirect) {\n    // Write the request entity and end.\n    var i = 0;\n    var self = this;\n    var buffers = this._requestBodyBuffers;\n\n    (function writeNext(error) {\n      // Only write if this request has not been redirected yet\n\n      /* istanbul ignore else */\n      if (request === self._currentRequest) {\n        // Report any write errors\n\n        /* istanbul ignore if */\n        if (error) {\n          self.emit(\"error\", error);\n        } // Write the next buffer if there are still left\n        else if (i < buffers.length) {\n          var buffer = buffers[i++];\n          /* istanbul ignore else */\n\n          if (!request.finished) {\n            request.write(buffer.data, buffer.encoding, writeNext);\n          }\n        } // End the request if `end` has been called on us\n        else if (self._ended) {\n          request.end();\n        }\n      }\n    })();\n  }\n}; // Processes a response from the current native request\n\n\nRedirectableRequest.prototype._processResponse = function (response) {\n  // Store the redirected response\n  var statusCode = response.statusCode;\n\n  if (this._options.trackRedirects) {\n    this._redirects.push({\n      url: this._currentUrl,\n      headers: response.headers,\n      statusCode: statusCode\n    });\n  } // RFC72316.4: The 3xx (Redirection) class of status code indicates\n  // that further action needs to be taken by the user agent in order to\n  // fulfill the request. If a Location header field is provided,\n  // the user agent MAY automatically redirect its request to the URI\n  // referenced by the Location field value,\n  // even if the specific status code is not understood.\n\n\n  var location = response.headers.location;\n\n  if (location && this._options.followRedirects !== false && statusCode >= 300 && statusCode < 400) {\n    // Abort the current request\n    abortRequest(this._currentRequest); // Discard the remainder of the response to avoid waiting for data\n\n    response.destroy(); // RFC72316.4: A client SHOULD detect and intervene\n    // in cyclical redirections (i.e., \"infinite\" redirection loops).\n\n    if (++this._redirectCount > this._options.maxRedirects) {\n      this.emit(\"error\", new TooManyRedirectsError());\n      return;\n    } // RFC72316.4: Automatic redirection needs to done with\n    // care for methods not known to be safe, []\n    // RFC72316.4.23: For historical reasons, a user agent MAY change\n    // the request method from POST to GET for the subsequent request.\n\n\n    if ((statusCode === 301 || statusCode === 302) && this._options.method === \"POST\" || // RFC72316.4.4: The 303 (See Other) status code indicates that\n    // the server is redirecting the user agent to a different resource []\n    // A user agent can perform a retrieval request targeting that URI\n    // (a GET or HEAD request if using HTTP) []\n    statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {\n      this._options.method = \"GET\"; // Drop a possible entity and headers related to it\n\n      this._requestBodyBuffers = [];\n      removeMatchingHeaders(/^content-/i, this._options.headers);\n    } // Drop the Host header, as the redirect might lead to a different host\n\n\n    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers); // If the redirect is relative, carry over the host of the last request\n\n    var currentUrlParts = url.parse(this._currentUrl);\n    var currentHost = currentHostHeader || currentUrlParts.host;\n    var currentUrl = /^\\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, {\n      host: currentHost\n    })); // Determine the URL of the redirection\n\n    var redirectUrl;\n\n    try {\n      redirectUrl = url.resolve(currentUrl, location);\n    } catch (cause) {\n      this.emit(\"error\", new RedirectionError(cause));\n      return;\n    } // Create the redirected request\n\n\n    debug(\"redirecting to\", redirectUrl);\n    this._isRedirect = true;\n    var redirectUrlParts = url.parse(redirectUrl);\n    Object.assign(this._options, redirectUrlParts); // Drop the confidential headers when redirecting to another domain\n\n    if (!(redirectUrlParts.host === currentHost || isSubdomainOf(redirectUrlParts.host, currentHost))) {\n      removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);\n    } // Evaluate the beforeRedirect callback\n\n\n    if (typeof this._options.beforeRedirect === \"function\") {\n      var responseDetails = {\n        headers: response.headers\n      };\n\n      try {\n        this._options.beforeRedirect.call(null, this._options, responseDetails);\n      } catch (err) {\n        this.emit(\"error\", err);\n        return;\n      }\n\n      this._sanitizeOptions(this._options);\n    } // Perform the redirected request\n\n\n    try {\n      this._performRequest();\n    } catch (cause) {\n      this.emit(\"error\", new RedirectionError(cause));\n    }\n  } else {\n    // The response is not a redirect; return it as-is\n    response.responseUrl = this._currentUrl;\n    response.redirects = this._redirects;\n    this.emit(\"response\", response); // Clean up\n\n    this._requestBodyBuffers = [];\n  }\n}; // Wraps the key/value object of protocols with redirect functionality\n\n\nfunction wrap(protocols) {\n  // Default settings\n  var exports = {\n    maxRedirects: 21,\n    maxBodyLength: 10 * 1024 * 1024\n  }; // Wrap each protocol\n\n  var nativeProtocols = {};\n  Object.keys(protocols).forEach(function (scheme) {\n    var protocol = scheme + \":\";\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol); // Executes a request, following redirects\n\n    function request(input, options, callback) {\n      // Parse parameters\n      if (typeof input === \"string\") {\n        var urlStr = input;\n\n        try {\n          input = urlToOptions(new URL(urlStr));\n        } catch (err) {\n          /* istanbul ignore next */\n          input = url.parse(urlStr);\n        }\n      } else if (URL && input instanceof URL) {\n        input = urlToOptions(input);\n      } else {\n        callback = options;\n        options = input;\n        input = {\n          protocol: protocol\n        };\n      }\n\n      if (typeof options === \"function\") {\n        callback = options;\n        options = null;\n      } // Set defaults\n\n\n      options = Object.assign({\n        maxRedirects: exports.maxRedirects,\n        maxBodyLength: exports.maxBodyLength\n      }, input, options);\n      options.nativeProtocols = nativeProtocols;\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\n      debug(\"options\", options);\n      return new RedirectableRequest(options, callback);\n    } // Executes a GET request, following redirects\n\n\n    function get(input, options, callback) {\n      var wrappedRequest = wrappedProtocol.request(input, options, callback);\n      wrappedRequest.end();\n      return wrappedRequest;\n    } // Expose the properties on the wrapped protocol\n\n\n    Object.defineProperties(wrappedProtocol, {\n      request: {\n        value: request,\n        configurable: true,\n        enumerable: true,\n        writable: true\n      },\n      get: {\n        value: get,\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }\n    });\n  });\n  return exports;\n}\n/* istanbul ignore next */\n\n\nfunction noop() {\n  /* empty */\n} // from https://github.com/nodejs/node/blob/master/lib/internal/url.js\n\n\nfunction urlToOptions(urlObject) {\n  var options = {\n    protocol: urlObject.protocol,\n    hostname: urlObject.hostname.startsWith(\"[\") ?\n    /* istanbul ignore next */\n    urlObject.hostname.slice(1, -1) : urlObject.hostname,\n    hash: urlObject.hash,\n    search: urlObject.search,\n    pathname: urlObject.pathname,\n    path: urlObject.pathname + urlObject.search,\n    href: urlObject.href\n  };\n\n  if (urlObject.port !== \"\") {\n    options.port = Number(urlObject.port);\n  }\n\n  return options;\n}\n\nfunction removeMatchingHeaders(regex, headers) {\n  var lastValue;\n\n  for (var header in headers) {\n    if (regex.test(header)) {\n      lastValue = headers[header];\n      delete headers[header];\n    }\n  }\n\n  return lastValue === null || typeof lastValue === \"undefined\" ? undefined : String(lastValue).trim();\n}\n\nfunction createErrorType(code, defaultMessage) {\n  function CustomError(cause) {\n    Error.captureStackTrace(this, this.constructor);\n\n    if (!cause) {\n      this.message = defaultMessage;\n    } else {\n      this.message = defaultMessage + \": \" + cause.message;\n      this.cause = cause;\n    }\n  }\n\n  CustomError.prototype = new Error();\n  CustomError.prototype.constructor = CustomError;\n  CustomError.prototype.name = \"Error [\" + code + \"]\";\n  CustomError.prototype.code = code;\n  return CustomError;\n}\n\nfunction abortRequest(request) {\n  for (var e = 0; e < events.length; e++) {\n    request.removeListener(events[e], eventHandlers[events[e]]);\n  }\n\n  request.on(\"error\", noop);\n  request.abort();\n}\n\nfunction isSubdomainOf(subdomain, domain) {\n  const dot = subdomain.length - domain.length - 1;\n  return dot > 0 && subdomain[dot] === \".\" && subdomain.endsWith(domain);\n} // Exports\n\n\nmodule.exports = wrap({\n  http: http,\n  https: https\n});\nmodule.exports.wrap = wrap;","'use strict';\n\nmodule.exports = (flag, argv) => {\n  argv = argv || process.argv;\n  const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';\n  const pos = argv.indexOf(prefix + flag);\n  const terminatorPos = argv.indexOf('--');\n  return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);\n};","/**\n * Helpers.\n */\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n};\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\n\nfunction parse(str) {\n  str = String(str);\n\n  if (str.length > 100) {\n    return;\n  }\n\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n\n  if (!match) {\n    return;\n  }\n\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n\n    default:\n      return undefined;\n  }\n}\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n\n  return ms + 'ms';\n}\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n\n  return ms + ' ms';\n}\n/**\n * Pluralization helper.\n */\n\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}","/**\n * Compiles a querystring\n * Returns string representation of the object\n *\n * @param {Object}\n * @api private\n */\nexports.encode = function (obj) {\n  var str = '';\n\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      if (str.length) str += '&';\n      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n    }\n  }\n\n  return str;\n};\n/**\n * Parses a simple querystring into an object\n *\n * @param {String} qs\n * @api private\n */\n\n\nexports.decode = function (qs) {\n  var qry = {};\n  var pairs = qs.split('&');\n\n  for (var i = 0, l = pairs.length; i < l; i++) {\n    var pair = pairs[i].split('=');\n    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n  }\n\n  return qry;\n};","/**\n * Parses an URI\n *\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\n * @api private\n */\nvar re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\nvar parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];\n\nmodule.exports = function parseuri(str) {\n  var src = str,\n      b = str.indexOf('['),\n      e = str.indexOf(']');\n\n  if (b != -1 && e != -1) {\n    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n  }\n\n  var m = re.exec(str || ''),\n      uri = {},\n      i = 14;\n\n  while (i--) {\n    uri[parts[i]] = m[i] || '';\n  }\n\n  if (b != -1 && e != -1) {\n    uri.source = src;\n    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n    uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n    uri.ipv6uri = true;\n  }\n\n  uri.pathNames = pathNames(uri, uri['path']);\n  uri.queryKey = queryKey(uri, uri['query']);\n  return uri;\n};\n\nfunction pathNames(obj, path) {\n  var regx = /\\/{2,9}/g,\n      names = path.replace(regx, \"/\").split(\"/\");\n\n  if (path.substr(0, 1) == '/' || path.length === 0) {\n    names.splice(0, 1);\n  }\n\n  if (path.substr(path.length - 1, 1) == '/') {\n    names.splice(names.length - 1, 1);\n  }\n\n  return names;\n}\n\nfunction queryKey(uri, query) {\n  var data = {};\n  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {\n    if ($1) {\n      data[$1] = $2;\n    }\n  });\n  return data;\n}","import parseuri from \"parseuri\";\nimport debugModule from \"debug\"; // debug()\n\nconst debug = debugModule(\"socket.io-client:url\"); // debug()\n\n/**\n * URL parser.\n *\n * @param uri - url\n * @param path - the request path of the connection\n * @param loc - An object meant to mimic window.location.\n *        Defaults to window.location.\n * @public\n */\n\nexport function url(uri, path = \"\", loc) {\n  let obj = uri; // default to window.location\n\n  loc = loc || typeof location !== \"undefined\" && location;\n  if (null == uri) uri = loc.protocol + \"//\" + loc.host; // relative path support\n\n  if (typeof uri === \"string\") {\n    if (\"/\" === uri.charAt(0)) {\n      if (\"/\" === uri.charAt(1)) {\n        uri = loc.protocol + uri;\n      } else {\n        uri = loc.host + uri;\n      }\n    }\n\n    if (!/^(https?|wss?):\\/\\//.test(uri)) {\n      debug(\"protocol-less url %s\", uri);\n\n      if (\"undefined\" !== typeof loc) {\n        uri = loc.protocol + \"//\" + uri;\n      } else {\n        uri = \"https://\" + uri;\n      }\n    } // parse\n\n\n    debug(\"parse %s\", uri);\n    obj = parseuri(uri);\n  } // make sure we treat `localhost:80` and `localhost` equally\n\n\n  if (!obj.port) {\n    if (/^(http|ws)$/.test(obj.protocol)) {\n      obj.port = \"80\";\n    } else if (/^(http|ws)s$/.test(obj.protocol)) {\n      obj.port = \"443\";\n    }\n  }\n\n  obj.path = obj.path || \"/\";\n  const ipv6 = obj.host.indexOf(\":\") !== -1;\n  const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host; // define unique id\n\n  obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path; // define href\n\n  obj.href = obj.protocol + \"://\" + host + (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n  return obj;\n}","import * as XMLHttpRequestModule from \"xmlhttprequest-ssl\";\nconst XMLHttpRequest = XMLHttpRequestModule.default || XMLHttpRequestModule;\nexport default XMLHttpRequest;","export default global;","import globalThis from \"./globalThis.js\";\nexport function pick(obj, ...attr) {\n  return attr.reduce((acc, k) => {\n    if (obj.hasOwnProperty(k)) {\n      acc[k] = obj[k];\n    }\n\n    return acc;\n  }, {});\n} // Keep a reference to the real timeout functions so they can be used when overridden\n\nconst NATIVE_SET_TIMEOUT = setTimeout;\nconst NATIVE_CLEAR_TIMEOUT = clearTimeout;\nexport function installTimerFunctions(obj, opts) {\n  if (opts.useNativeTimers) {\n    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis);\n    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis);\n  } else {\n    obj.setTimeoutFn = setTimeout.bind(globalThis);\n    obj.clearTimeoutFn = clearTimeout.bind(globalThis);\n  }\n}","const PACKET_TYPES = Object.create(null); // no Map = no polyfill\n\nPACKET_TYPES[\"open\"] = \"0\";\nPACKET_TYPES[\"close\"] = \"1\";\nPACKET_TYPES[\"ping\"] = \"2\";\nPACKET_TYPES[\"pong\"] = \"3\";\nPACKET_TYPES[\"message\"] = \"4\";\nPACKET_TYPES[\"upgrade\"] = \"5\";\nPACKET_TYPES[\"noop\"] = \"6\";\nconst PACKET_TYPES_REVERSE = Object.create(null);\nObject.keys(PACKET_TYPES).forEach(key => {\n  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;\n});\nconst ERROR_PACKET = {\n  type: \"error\",\n  data: \"parser error\"\n};\nexport { PACKET_TYPES, PACKET_TYPES_REVERSE, ERROR_PACKET };","import { PACKET_TYPES } from \"./commons.js\";\n\nconst encodePacket = ({\n  type,\n  data\n}, supportsBinary, callback) => {\n  if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {\n    const buffer = toBuffer(data);\n    return callback(encodeBuffer(buffer, supportsBinary));\n  } // plain string\n\n\n  return callback(PACKET_TYPES[type] + (data || \"\"));\n};\n\nconst toBuffer = data => {\n  if (Buffer.isBuffer(data)) {\n    return data;\n  } else if (data instanceof ArrayBuffer) {\n    return Buffer.from(data);\n  } else {\n    return Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n  }\n}; // only 'message' packets can contain binary, so the type prefix is not needed\n\n\nconst encodeBuffer = (data, supportsBinary) => {\n  return supportsBinary ? data : \"b\" + data.toString(\"base64\");\n};\n\nexport default encodePacket;","import { ERROR_PACKET, PACKET_TYPES_REVERSE } from \"./commons.js\";\n\nconst decodePacket = (encodedPacket, binaryType) => {\n  if (typeof encodedPacket !== \"string\") {\n    return {\n      type: \"message\",\n      data: mapBinary(encodedPacket, binaryType)\n    };\n  }\n\n  const type = encodedPacket.charAt(0);\n\n  if (type === \"b\") {\n    const buffer = Buffer.from(encodedPacket.substring(1), \"base64\");\n    return {\n      type: \"message\",\n      data: mapBinary(buffer, binaryType)\n    };\n  }\n\n  if (!PACKET_TYPES_REVERSE[type]) {\n    return ERROR_PACKET;\n  }\n\n  return encodedPacket.length > 1 ? {\n    type: PACKET_TYPES_REVERSE[type],\n    data: encodedPacket.substring(1)\n  } : {\n    type: PACKET_TYPES_REVERSE[type]\n  };\n};\n\nconst mapBinary = (data, binaryType) => {\n  const isBuffer = Buffer.isBuffer(data);\n\n  switch (binaryType) {\n    case \"arraybuffer\":\n      return isBuffer ? toArrayBuffer(data) : data;\n\n    case \"nodebuffer\":\n    default:\n      return data;\n    // assuming the data is already a Buffer\n  }\n};\n\nconst toArrayBuffer = buffer => {\n  const arrayBuffer = new ArrayBuffer(buffer.length);\n  const view = new Uint8Array(arrayBuffer);\n\n  for (let i = 0; i < buffer.length; i++) {\n    view[i] = buffer[i];\n  }\n\n  return arrayBuffer;\n};\n\nexport default decodePacket;","import encodePacket from \"./encodePacket.js\";\nimport decodePacket from \"./decodePacket.js\";\nconst SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\n\nconst encodePayload = (packets, callback) => {\n  // some packets may be added to the array while encoding, so the initial length must be saved\n  const length = packets.length;\n  const encodedPackets = new Array(length);\n  let count = 0;\n  packets.forEach((packet, i) => {\n    // force base64 encoding for binary packets\n    encodePacket(packet, false, encodedPacket => {\n      encodedPackets[i] = encodedPacket;\n\n      if (++count === length) {\n        callback(encodedPackets.join(SEPARATOR));\n      }\n    });\n  });\n};\n\nconst decodePayload = (encodedPayload, binaryType) => {\n  const encodedPackets = encodedPayload.split(SEPARATOR);\n  const packets = [];\n\n  for (let i = 0; i < encodedPackets.length; i++) {\n    const decodedPacket = decodePacket(encodedPackets[i], binaryType);\n    packets.push(decodedPacket);\n\n    if (decodedPacket.type === \"error\") {\n      break;\n    }\n  }\n\n  return packets;\n};\n\nexport const protocol = 4;\nexport { encodePacket, encodePayload, decodePacket, decodePayload };","import { decodePacket } from \"engine.io-parser\";\nimport { Emitter } from \"@socket.io/component-emitter\";\nimport { installTimerFunctions } from \"./util.js\";\nimport debugModule from \"debug\"; // debug()\n\nconst debug = debugModule(\"engine.io-client:transport\"); // debug()\n\nexport class Transport extends Emitter {\n  /**\n   * Transport abstract constructor.\n   *\n   * @param {Object} options.\n   * @api private\n   */\n  constructor(opts) {\n    super();\n    this.writable = false;\n    installTimerFunctions(this, opts);\n    this.opts = opts;\n    this.query = opts.query;\n    this.readyState = \"\";\n    this.socket = opts.socket;\n  }\n  /**\n   * Emits an error.\n   *\n   * @param {String} str\n   * @return {Transport} for chaining\n   * @api protected\n   */\n\n\n  onError(msg, desc) {\n    const err = new Error(msg); // @ts-ignore\n\n    err.type = \"TransportError\"; // @ts-ignore\n\n    err.description = desc;\n    super.emit(\"error\", err);\n    return this;\n  }\n  /**\n   * Opens the transport.\n   *\n   * @api public\n   */\n\n\n  open() {\n    if (\"closed\" === this.readyState || \"\" === this.readyState) {\n      this.readyState = \"opening\";\n      this.doOpen();\n    }\n\n    return this;\n  }\n  /**\n   * Closes the transport.\n   *\n   * @api public\n   */\n\n\n  close() {\n    if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n      this.doClose();\n      this.onClose();\n    }\n\n    return this;\n  }\n  /**\n   * Sends multiple packets.\n   *\n   * @param {Array} packets\n   * @api public\n   */\n\n\n  send(packets) {\n    if (\"open\" === this.readyState) {\n      this.write(packets);\n    } else {\n      // this might happen if the transport was silently closed in the beforeunload event handler\n      debug(\"transport is not open, discarding packets\");\n    }\n  }\n  /**\n   * Called upon open\n   *\n   * @api protected\n   */\n\n\n  onOpen() {\n    this.readyState = \"open\";\n    this.writable = true;\n    super.emit(\"open\");\n  }\n  /**\n   * Called with data.\n   *\n   * @param {String} data\n   * @api protected\n   */\n\n\n  onData(data) {\n    const packet = decodePacket(data, this.socket.binaryType);\n    this.onPacket(packet);\n  }\n  /**\n   * Called with a decoded packet.\n   *\n   * @api protected\n   */\n\n\n  onPacket(packet) {\n    super.emit(\"packet\", packet);\n  }\n  /**\n   * Called upon close.\n   *\n   * @api protected\n   */\n\n\n  onClose() {\n    this.readyState = \"closed\";\n    super.emit(\"close\");\n  }\n\n}","import { Transport } from \"../transport.js\";\nimport debugModule from \"debug\"; // debug()\n\nimport yeast from \"yeast\";\nimport parseqs from \"parseqs\";\nimport { encodePayload, decodePayload } from \"engine.io-parser\";\nconst debug = debugModule(\"engine.io-client:polling\"); // debug()\n\nexport class Polling extends Transport {\n  constructor() {\n    super(...arguments);\n    this.polling = false;\n  }\n  /**\n   * Transport name.\n   */\n\n\n  get name() {\n    return \"polling\";\n  }\n  /**\n   * Opens the socket (triggers polling). We write a PING message to determine\n   * when the transport is open.\n   *\n   * @api private\n   */\n\n\n  doOpen() {\n    this.poll();\n  }\n  /**\n   * Pauses polling.\n   *\n   * @param {Function} callback upon buffers are flushed and transport is paused\n   * @api private\n   */\n\n\n  pause(onPause) {\n    this.readyState = \"pausing\";\n\n    const pause = () => {\n      debug(\"paused\");\n      this.readyState = \"paused\";\n      onPause();\n    };\n\n    if (this.polling || !this.writable) {\n      let total = 0;\n\n      if (this.polling) {\n        debug(\"we are currently polling - waiting to pause\");\n        total++;\n        this.once(\"pollComplete\", function () {\n          debug(\"pre-pause polling complete\");\n          --total || pause();\n        });\n      }\n\n      if (!this.writable) {\n        debug(\"we are currently writing - waiting to pause\");\n        total++;\n        this.once(\"drain\", function () {\n          debug(\"pre-pause writing complete\");\n          --total || pause();\n        });\n      }\n    } else {\n      pause();\n    }\n  }\n  /**\n   * Starts polling cycle.\n   *\n   * @api public\n   */\n\n\n  poll() {\n    debug(\"polling\");\n    this.polling = true;\n    this.doPoll();\n    this.emit(\"poll\");\n  }\n  /**\n   * Overloads onData to detect payloads.\n   *\n   * @api private\n   */\n\n\n  onData(data) {\n    debug(\"polling got data %s\", data);\n\n    const callback = packet => {\n      // if its the first message we consider the transport open\n      if (\"opening\" === this.readyState && packet.type === \"open\") {\n        this.onOpen();\n      } // if its a close packet, we close the ongoing requests\n\n\n      if (\"close\" === packet.type) {\n        this.onClose();\n        return false;\n      } // otherwise bypass onData and handle the message\n\n\n      this.onPacket(packet);\n    }; // decode payload\n\n\n    decodePayload(data, this.socket.binaryType).forEach(callback); // if an event did not trigger closing\n\n    if (\"closed\" !== this.readyState) {\n      // if we got data we're not polling\n      this.polling = false;\n      this.emit(\"pollComplete\");\n\n      if (\"open\" === this.readyState) {\n        this.poll();\n      } else {\n        debug('ignoring poll - transport state \"%s\"', this.readyState);\n      }\n    }\n  }\n  /**\n   * For polling, send a close packet.\n   *\n   * @api private\n   */\n\n\n  doClose() {\n    const close = () => {\n      debug(\"writing close packet\");\n      this.write([{\n        type: \"close\"\n      }]);\n    };\n\n    if (\"open\" === this.readyState) {\n      debug(\"transport open - closing\");\n      close();\n    } else {\n      // in case we're trying to close while\n      // handshaking is in progress (GH-164)\n      debug(\"transport not open - deferring close\");\n      this.once(\"open\", close);\n    }\n  }\n  /**\n   * Writes a packets payload.\n   *\n   * @param {Array} data packets\n   * @param {Function} drain callback\n   * @api private\n   */\n\n\n  write(packets) {\n    this.writable = false;\n    encodePayload(packets, data => {\n      this.doWrite(data, () => {\n        this.writable = true;\n        this.emit(\"drain\");\n      });\n    });\n  }\n  /**\n   * Generates uri for connection.\n   *\n   * @api private\n   */\n\n\n  uri() {\n    let query = this.query || {};\n    const schema = this.opts.secure ? \"https\" : \"http\";\n    let port = \"\"; // cache busting is forced\n\n    if (false !== this.opts.timestampRequests) {\n      query[this.opts.timestampParam] = yeast();\n    }\n\n    if (!this.supportsBinary && !query.sid) {\n      query.b64 = 1;\n    } // avoid port if default for schema\n\n\n    if (this.opts.port && (\"https\" === schema && Number(this.opts.port) !== 443 || \"http\" === schema && Number(this.opts.port) !== 80)) {\n      port = \":\" + this.opts.port;\n    }\n\n    const encodedQuery = parseqs.encode(query);\n    const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n    return schema + \"://\" + (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? \"?\" + encodedQuery : \"\");\n  }\n\n}","/* global attachEvent */\nimport XMLHttpRequest from \"./xmlhttprequest.js\";\nimport debugModule from \"debug\"; // debug()\n\nimport globalThis from \"../globalThis.js\";\nimport { installTimerFunctions, pick } from \"../util.js\";\nimport { Emitter } from \"@socket.io/component-emitter\";\nimport { Polling } from \"./polling.js\";\nconst debug = debugModule(\"engine.io-client:polling-xhr\"); // debug()\n\n/**\n * Empty function\n */\n\nfunction empty() {}\n\nconst hasXHR2 = function () {\n  const xhr = new XMLHttpRequest({\n    xdomain: false\n  });\n  return null != xhr.responseType;\n}();\n\nexport class XHR extends Polling {\n  /**\n   * XHR Polling constructor.\n   *\n   * @param {Object} opts\n   * @api public\n   */\n  constructor(opts) {\n    super(opts);\n\n    if (typeof location !== \"undefined\") {\n      const isSSL = \"https:\" === location.protocol;\n      let port = location.port; // some user agents have empty `location.port`\n\n      if (!port) {\n        port = isSSL ? \"443\" : \"80\";\n      }\n\n      this.xd = typeof location !== \"undefined\" && opts.hostname !== location.hostname || port !== opts.port;\n      this.xs = opts.secure !== isSSL;\n    }\n    /**\n     * XHR supports binary\n     */\n\n\n    const forceBase64 = opts && opts.forceBase64;\n    this.supportsBinary = hasXHR2 && !forceBase64;\n  }\n  /**\n   * Creates a request.\n   *\n   * @param {String} method\n   * @api private\n   */\n\n\n  request(opts = {}) {\n    Object.assign(opts, {\n      xd: this.xd,\n      xs: this.xs\n    }, this.opts);\n    return new Request(this.uri(), opts);\n  }\n  /**\n   * Sends data.\n   *\n   * @param {String} data to send.\n   * @param {Function} called upon flush.\n   * @api private\n   */\n\n\n  doWrite(data, fn) {\n    const req = this.request({\n      method: \"POST\",\n      data: data\n    });\n    req.on(\"success\", fn);\n    req.on(\"error\", err => {\n      this.onError(\"xhr post error\", err);\n    });\n  }\n  /**\n   * Starts a poll cycle.\n   *\n   * @api private\n   */\n\n\n  doPoll() {\n    debug(\"xhr poll\");\n    const req = this.request();\n    req.on(\"data\", this.onData.bind(this));\n    req.on(\"error\", err => {\n      this.onError(\"xhr poll error\", err);\n    });\n    this.pollXhr = req;\n  }\n\n}\nexport class Request extends Emitter {\n  /**\n   * Request constructor\n   *\n   * @param {Object} options\n   * @api public\n   */\n  constructor(uri, opts) {\n    super();\n    installTimerFunctions(this, opts);\n    this.opts = opts;\n    this.method = opts.method || \"GET\";\n    this.uri = uri;\n    this.async = false !== opts.async;\n    this.data = undefined !== opts.data ? opts.data : null;\n    this.create();\n  }\n  /**\n   * Creates the XHR object and sends the request.\n   *\n   * @api private\n   */\n\n\n  create() {\n    const opts = pick(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n    opts.xdomain = !!this.opts.xd;\n    opts.xscheme = !!this.opts.xs;\n    const xhr = this.xhr = new XMLHttpRequest(opts);\n\n    try {\n      debug(\"xhr open %s: %s\", this.method, this.uri);\n      xhr.open(this.method, this.uri, this.async);\n\n      try {\n        if (this.opts.extraHeaders) {\n          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n\n          for (let i in this.opts.extraHeaders) {\n            if (this.opts.extraHeaders.hasOwnProperty(i)) {\n              xhr.setRequestHeader(i, this.opts.extraHeaders[i]);\n            }\n          }\n        }\n      } catch (e) {}\n\n      if (\"POST\" === this.method) {\n        try {\n          xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n        } catch (e) {}\n      }\n\n      try {\n        xhr.setRequestHeader(\"Accept\", \"*/*\");\n      } catch (e) {} // ie6 check\n\n\n      if (\"withCredentials\" in xhr) {\n        xhr.withCredentials = this.opts.withCredentials;\n      }\n\n      if (this.opts.requestTimeout) {\n        xhr.timeout = this.opts.requestTimeout;\n      }\n\n      xhr.onreadystatechange = () => {\n        if (4 !== xhr.readyState) return;\n\n        if (200 === xhr.status || 1223 === xhr.status) {\n          this.onLoad();\n        } else {\n          // make sure the `error` event handler that's user-set\n          // does not throw in the same tick and gets caught here\n          this.setTimeoutFn(() => {\n            this.onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n          }, 0);\n        }\n      };\n\n      debug(\"xhr data %s\", this.data);\n      xhr.send(this.data);\n    } catch (e) {\n      // Need to defer since .create() is called directly from the constructor\n      // and thus the 'error' event can only be only bound *after* this exception\n      // occurs.  Therefore, also, we cannot throw here at all.\n      this.setTimeoutFn(() => {\n        this.onError(e);\n      }, 0);\n      return;\n    }\n\n    if (typeof document !== \"undefined\") {\n      this.index = Request.requestsCount++;\n      Request.requests[this.index] = this;\n    }\n  }\n  /**\n   * Called upon successful response.\n   *\n   * @api private\n   */\n\n\n  onSuccess() {\n    this.emit(\"success\");\n    this.cleanup();\n  }\n  /**\n   * Called if we have data.\n   *\n   * @api private\n   */\n\n\n  onData(data) {\n    this.emit(\"data\", data);\n    this.onSuccess();\n  }\n  /**\n   * Called upon error.\n   *\n   * @api private\n   */\n\n\n  onError(err) {\n    this.emit(\"error\", err);\n    this.cleanup(true);\n  }\n  /**\n   * Cleans up house.\n   *\n   * @api private\n   */\n\n\n  cleanup(fromError) {\n    if (\"undefined\" === typeof this.xhr || null === this.xhr) {\n      return;\n    }\n\n    this.xhr.onreadystatechange = empty;\n\n    if (fromError) {\n      try {\n        this.xhr.abort();\n      } catch (e) {}\n    }\n\n    if (typeof document !== \"undefined\") {\n      delete Request.requests[this.index];\n    }\n\n    this.xhr = null;\n  }\n  /**\n   * Called upon load.\n   *\n   * @api private\n   */\n\n\n  onLoad() {\n    const data = this.xhr.responseText;\n\n    if (data !== null) {\n      this.onData(data);\n    }\n  }\n  /**\n   * Aborts the request.\n   *\n   * @api public\n   */\n\n\n  abort() {\n    this.cleanup();\n  }\n\n}\nRequest.requestsCount = 0;\nRequest.requests = {};\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\n\nif (typeof document !== \"undefined\") {\n  // @ts-ignore\n  if (typeof attachEvent === \"function\") {\n    // @ts-ignore\n    attachEvent(\"onunload\", unloadHandler);\n  } else if (typeof addEventListener === \"function\") {\n    const terminationEvent = \"onpagehide\" in globalThis ? \"pagehide\" : \"unload\";\n    addEventListener(terminationEvent, unloadHandler, false);\n  }\n}\n\nfunction unloadHandler() {\n  for (let i in Request.requests) {\n    if (Request.requests.hasOwnProperty(i)) {\n      Request.requests[i].abort();\n    }\n  }\n}","import createWebSocketStream from './lib/stream.js';\nimport Receiver from './lib/receiver.js';\nimport Sender from './lib/sender.js';\nimport WebSocket from './lib/websocket.js';\nimport WebSocketServer from './lib/websocket-server.js';\n\nexport { createWebSocketStream, Receiver, Sender, WebSocket, WebSocketServer };\nexport default WebSocket;\n","import ws from \"ws\";\nexport const WebSocket = ws;\nexport const usingBrowserWebSocket = false;\nexport const defaultBinaryType = \"nodebuffer\";\nexport const nextTick = process.nextTick;","import { Transport } from \"../transport.js\";\nimport parseqs from \"parseqs\";\nimport yeast from \"yeast\";\nimport { pick } from \"../util.js\";\nimport { defaultBinaryType, nextTick, usingBrowserWebSocket, WebSocket } from \"./websocket-constructor.js\";\nimport debugModule from \"debug\"; // debug()\n\nimport { encodePacket } from \"engine.io-parser\";\nconst debug = debugModule(\"engine.io-client:websocket\"); // debug()\n// detect ReactNative environment\n\nconst isReactNative = typeof navigator !== \"undefined\" && typeof navigator.product === \"string\" && navigator.product.toLowerCase() === \"reactnative\";\nexport class WS extends Transport {\n  /**\n   * WebSocket transport constructor.\n   *\n   * @api {Object} connection options\n   * @api public\n   */\n  constructor(opts) {\n    super(opts);\n    this.supportsBinary = !opts.forceBase64;\n  }\n  /**\n   * Transport name.\n   *\n   * @api public\n   */\n\n\n  get name() {\n    return \"websocket\";\n  }\n  /**\n   * Opens socket.\n   *\n   * @api private\n   */\n\n\n  doOpen() {\n    if (!this.check()) {\n      // let probe timeout\n      return;\n    }\n\n    const uri = this.uri();\n    const protocols = this.opts.protocols; // React Native only supports the 'headers' option, and will print a warning if anything else is passed\n\n    const opts = isReactNative ? {} : pick(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n\n    if (this.opts.extraHeaders) {\n      opts.headers = this.opts.extraHeaders;\n    }\n\n    try {\n      this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);\n    } catch (err) {\n      return this.emit(\"error\", err);\n    }\n\n    this.ws.binaryType = this.socket.binaryType || defaultBinaryType;\n    this.addEventListeners();\n  }\n  /**\n   * Adds event listeners to the socket\n   *\n   * @api private\n   */\n\n\n  addEventListeners() {\n    this.ws.onopen = () => {\n      if (this.opts.autoUnref) {\n        this.ws._socket.unref();\n      }\n\n      this.onOpen();\n    };\n\n    this.ws.onclose = this.onClose.bind(this);\n\n    this.ws.onmessage = ev => this.onData(ev.data);\n\n    this.ws.onerror = e => this.onError(\"websocket error\", e);\n  }\n  /**\n   * Writes data to socket.\n   *\n   * @param {Array} array of packets.\n   * @api private\n   */\n\n\n  write(packets) {\n    this.writable = false; // encodePacket efficient as it uses WS framing\n    // no need for encodePayload\n\n    for (let i = 0; i < packets.length; i++) {\n      const packet = packets[i];\n      const lastPacket = i === packets.length - 1;\n      encodePacket(packet, this.supportsBinary, data => {\n        // always create a new object (GH-437)\n        const opts = {};\n\n        if (!usingBrowserWebSocket) {\n          if (packet.options) {\n            opts.compress = packet.options.compress;\n          }\n\n          if (this.opts.perMessageDeflate) {\n            const len = \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n\n            if (len < this.opts.perMessageDeflate.threshold) {\n              opts.compress = false;\n            }\n          }\n        } // Sometimes the websocket has already been closed but the browser didn't\n        // have a chance of informing us about it yet, in that case send will\n        // throw an error\n\n\n        try {\n          if (usingBrowserWebSocket) {\n            // TypeError is thrown when passing the second argument on Safari\n            this.ws.send(data);\n          } else {\n            this.ws.send(data, opts);\n          }\n        } catch (e) {\n          debug(\"websocket closed before onclose event\");\n        }\n\n        if (lastPacket) {\n          // fake drain\n          // defer to next tick to allow Socket to clear writeBuffer\n          nextTick(() => {\n            this.writable = true;\n            this.emit(\"drain\");\n          }, this.setTimeoutFn);\n        }\n      });\n    }\n  }\n  /**\n   * Closes socket.\n   *\n   * @api private\n   */\n\n\n  doClose() {\n    if (typeof this.ws !== \"undefined\") {\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n  /**\n   * Generates uri for connection.\n   *\n   * @api private\n   */\n\n\n  uri() {\n    let query = this.query || {};\n    const schema = this.opts.secure ? \"wss\" : \"ws\";\n    let port = \"\"; // avoid port if default for schema\n\n    if (this.opts.port && (\"wss\" === schema && Number(this.opts.port) !== 443 || \"ws\" === schema && Number(this.opts.port) !== 80)) {\n      port = \":\" + this.opts.port;\n    } // append timestamp to URI\n\n\n    if (this.opts.timestampRequests) {\n      query[this.opts.timestampParam] = yeast();\n    } // communicate binary support capabilities\n\n\n    if (!this.supportsBinary) {\n      query.b64 = 1;\n    }\n\n    const encodedQuery = parseqs.encode(query);\n    const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n    return schema + \"://\" + (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? \"?\" + encodedQuery : \"\");\n  }\n  /**\n   * Feature detection for WebSocket.\n   *\n   * @return {Boolean} whether this transport is available.\n   * @api public\n   */\n\n\n  check() {\n    return !!WebSocket && !(\"__initialize\" in WebSocket && this.name === WS.prototype.name);\n  }\n\n}","import { XHR } from \"./polling-xhr.js\";\nimport { WS } from \"./websocket.js\";\nexport const transports = {\n  websocket: WS,\n  polling: XHR\n};","import { transports } from \"./transports/index.js\";\nimport { installTimerFunctions } from \"./util.js\";\nimport parseqs from \"parseqs\";\nimport parseuri from \"parseuri\";\nimport debugModule from \"debug\"; // debug()\n\nimport { Emitter } from \"@socket.io/component-emitter\";\nimport { protocol } from \"engine.io-parser\";\nconst debug = debugModule(\"engine.io-client:socket\"); // debug()\n\nexport class Socket extends Emitter {\n  /**\n   * Socket constructor.\n   *\n   * @param {String|Object} uri or options\n   * @param {Object} opts - options\n   * @api public\n   */\n  constructor(uri, opts = {}) {\n    super();\n\n    if (uri && \"object\" === typeof uri) {\n      opts = uri;\n      uri = null;\n    }\n\n    if (uri) {\n      uri = parseuri(uri);\n      opts.hostname = uri.host;\n      opts.secure = uri.protocol === \"https\" || uri.protocol === \"wss\";\n      opts.port = uri.port;\n      if (uri.query) opts.query = uri.query;\n    } else if (opts.host) {\n      opts.hostname = parseuri(opts.host).host;\n    }\n\n    installTimerFunctions(this, opts);\n    this.secure = null != opts.secure ? opts.secure : typeof location !== \"undefined\" && \"https:\" === location.protocol;\n\n    if (opts.hostname && !opts.port) {\n      // if no port is specified manually, use the protocol default\n      opts.port = this.secure ? \"443\" : \"80\";\n    }\n\n    this.hostname = opts.hostname || (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\n    this.port = opts.port || (typeof location !== \"undefined\" && location.port ? location.port : this.secure ? \"443\" : \"80\");\n    this.transports = opts.transports || [\"polling\", \"websocket\"];\n    this.readyState = \"\";\n    this.writeBuffer = [];\n    this.prevBufferLen = 0;\n    this.opts = Object.assign({\n      path: \"/engine.io\",\n      agent: false,\n      withCredentials: false,\n      upgrade: true,\n      timestampParam: \"t\",\n      rememberUpgrade: false,\n      rejectUnauthorized: true,\n      perMessageDeflate: {\n        threshold: 1024\n      },\n      transportOptions: {},\n      closeOnBeforeunload: true\n    }, opts);\n    this.opts.path = this.opts.path.replace(/\\/$/, \"\") + \"/\";\n\n    if (typeof this.opts.query === \"string\") {\n      this.opts.query = parseqs.decode(this.opts.query);\n    } // set on handshake\n\n\n    this.id = null;\n    this.upgrades = null;\n    this.pingInterval = null;\n    this.pingTimeout = null; // set on heartbeat\n\n    this.pingTimeoutTimer = null;\n\n    if (typeof addEventListener === \"function\") {\n      if (this.opts.closeOnBeforeunload) {\n        // Firefox closes the connection when the \"beforeunload\" event is emitted but not Chrome. This event listener\n        // ensures every browser behaves the same (no \"disconnect\" event at the Socket.IO level when the page is\n        // closed/reloaded)\n        addEventListener(\"beforeunload\", () => {\n          if (this.transport) {\n            // silently close the transport\n            this.transport.removeAllListeners();\n            this.transport.close();\n          }\n        }, false);\n      }\n\n      if (this.hostname !== \"localhost\") {\n        this.offlineEventListener = () => {\n          this.onClose(\"transport close\");\n        };\n\n        addEventListener(\"offline\", this.offlineEventListener, false);\n      }\n    }\n\n    this.open();\n  }\n  /**\n   * Creates transport of the given type.\n   *\n   * @param {String} transport name\n   * @return {Transport}\n   * @api private\n   */\n\n\n  createTransport(name) {\n    debug('creating transport \"%s\"', name);\n    const query = clone(this.opts.query); // append engine.io protocol identifier\n\n    query.EIO = protocol; // transport name\n\n    query.transport = name; // session id if we already have one\n\n    if (this.id) query.sid = this.id;\n    const opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {\n      query,\n      socket: this,\n      hostname: this.hostname,\n      secure: this.secure,\n      port: this.port\n    });\n    debug(\"options: %j\", opts);\n    return new transports[name](opts);\n  }\n  /**\n   * Initializes transport to use and starts probe.\n   *\n   * @api private\n   */\n\n\n  open() {\n    let transport;\n\n    if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf(\"websocket\") !== -1) {\n      transport = \"websocket\";\n    } else if (0 === this.transports.length) {\n      // Emit error on next tick so it can be listened to\n      this.setTimeoutFn(() => {\n        this.emitReserved(\"error\", \"No transports available\");\n      }, 0);\n      return;\n    } else {\n      transport = this.transports[0];\n    }\n\n    this.readyState = \"opening\"; // Retry with the next transport if the transport is disabled (jsonp: false)\n\n    try {\n      transport = this.createTransport(transport);\n    } catch (e) {\n      debug(\"error while creating transport: %s\", e);\n      this.transports.shift();\n      this.open();\n      return;\n    }\n\n    transport.open();\n    this.setTransport(transport);\n  }\n  /**\n   * Sets the current transport. Disables the existing one (if any).\n   *\n   * @api private\n   */\n\n\n  setTransport(transport) {\n    debug(\"setting transport %s\", transport.name);\n\n    if (this.transport) {\n      debug(\"clearing existing transport %s\", this.transport.name);\n      this.transport.removeAllListeners();\n    } // set up transport\n\n\n    this.transport = transport; // set up transport listeners\n\n    transport.on(\"drain\", this.onDrain.bind(this)).on(\"packet\", this.onPacket.bind(this)).on(\"error\", this.onError.bind(this)).on(\"close\", () => {\n      this.onClose(\"transport close\");\n    });\n  }\n  /**\n   * Probes a transport.\n   *\n   * @param {String} transport name\n   * @api private\n   */\n\n\n  probe(name) {\n    debug('probing transport \"%s\"', name);\n    let transport = this.createTransport(name);\n    let failed = false;\n    Socket.priorWebsocketSuccess = false;\n\n    const onTransportOpen = () => {\n      if (failed) return;\n      debug('probe transport \"%s\" opened', name);\n      transport.send([{\n        type: \"ping\",\n        data: \"probe\"\n      }]);\n      transport.once(\"packet\", msg => {\n        if (failed) return;\n\n        if (\"pong\" === msg.type && \"probe\" === msg.data) {\n          debug('probe transport \"%s\" pong', name);\n          this.upgrading = true;\n          this.emitReserved(\"upgrading\", transport);\n          if (!transport) return;\n          Socket.priorWebsocketSuccess = \"websocket\" === transport.name;\n          debug('pausing current transport \"%s\"', this.transport.name);\n          this.transport.pause(() => {\n            if (failed) return;\n            if (\"closed\" === this.readyState) return;\n            debug(\"changing transport and sending upgrade packet\");\n            cleanup();\n            this.setTransport(transport);\n            transport.send([{\n              type: \"upgrade\"\n            }]);\n            this.emitReserved(\"upgrade\", transport);\n            transport = null;\n            this.upgrading = false;\n            this.flush();\n          });\n        } else {\n          debug('probe transport \"%s\" failed', name);\n          const err = new Error(\"probe error\"); // @ts-ignore\n\n          err.transport = transport.name;\n          this.emitReserved(\"upgradeError\", err);\n        }\n      });\n    };\n\n    function freezeTransport() {\n      if (failed) return; // Any callback called by transport should be ignored since now\n\n      failed = true;\n      cleanup();\n      transport.close();\n      transport = null;\n    } // Handle any error that happens while probing\n\n\n    const onerror = err => {\n      const error = new Error(\"probe error: \" + err); // @ts-ignore\n\n      error.transport = transport.name;\n      freezeTransport();\n      debug('probe transport \"%s\" failed because of error: %s', name, err);\n      this.emitReserved(\"upgradeError\", error);\n    };\n\n    function onTransportClose() {\n      onerror(\"transport closed\");\n    } // When the socket is closed while we're probing\n\n\n    function onclose() {\n      onerror(\"socket closed\");\n    } // When the socket is upgraded while we're probing\n\n\n    function onupgrade(to) {\n      if (transport && to.name !== transport.name) {\n        debug('\"%s\" works - aborting \"%s\"', to.name, transport.name);\n        freezeTransport();\n      }\n    } // Remove all listeners on the transport and on self\n\n\n    const cleanup = () => {\n      transport.removeListener(\"open\", onTransportOpen);\n      transport.removeListener(\"error\", onerror);\n      transport.removeListener(\"close\", onTransportClose);\n      this.off(\"close\", onclose);\n      this.off(\"upgrading\", onupgrade);\n    };\n\n    transport.once(\"open\", onTransportOpen);\n    transport.once(\"error\", onerror);\n    transport.once(\"close\", onTransportClose);\n    this.once(\"close\", onclose);\n    this.once(\"upgrading\", onupgrade);\n    transport.open();\n  }\n  /**\n   * Called when connection is deemed open.\n   *\n   * @api private\n   */\n\n\n  onOpen() {\n    debug(\"socket open\");\n    this.readyState = \"open\";\n    Socket.priorWebsocketSuccess = \"websocket\" === this.transport.name;\n    this.emitReserved(\"open\");\n    this.flush(); // we check for `readyState` in case an `open`\n    // listener already closed the socket\n\n    if (\"open\" === this.readyState && this.opts.upgrade && this.transport.pause) {\n      debug(\"starting upgrade probes\");\n      let i = 0;\n      const l = this.upgrades.length;\n\n      for (; i < l; i++) {\n        this.probe(this.upgrades[i]);\n      }\n    }\n  }\n  /**\n   * Handles a packet.\n   *\n   * @api private\n   */\n\n\n  onPacket(packet) {\n    if (\"opening\" === this.readyState || \"open\" === this.readyState || \"closing\" === this.readyState) {\n      debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data);\n      this.emitReserved(\"packet\", packet); // Socket is live - any packet counts\n\n      this.emitReserved(\"heartbeat\");\n\n      switch (packet.type) {\n        case \"open\":\n          this.onHandshake(JSON.parse(packet.data));\n          break;\n\n        case \"ping\":\n          this.resetPingTimeout();\n          this.sendPacket(\"pong\");\n          this.emitReserved(\"ping\");\n          this.emitReserved(\"pong\");\n          break;\n\n        case \"error\":\n          const err = new Error(\"server error\"); // @ts-ignore\n\n          err.code = packet.data;\n          this.onError(err);\n          break;\n\n        case \"message\":\n          this.emitReserved(\"data\", packet.data);\n          this.emitReserved(\"message\", packet.data);\n          break;\n      }\n    } else {\n      debug('packet received with socket readyState \"%s\"', this.readyState);\n    }\n  }\n  /**\n   * Called upon handshake completion.\n   *\n   * @param {Object} data - handshake obj\n   * @api private\n   */\n\n\n  onHandshake(data) {\n    this.emitReserved(\"handshake\", data);\n    this.id = data.sid;\n    this.transport.query.sid = data.sid;\n    this.upgrades = this.filterUpgrades(data.upgrades);\n    this.pingInterval = data.pingInterval;\n    this.pingTimeout = data.pingTimeout;\n    this.onOpen(); // In case open handler closes socket\n\n    if (\"closed\" === this.readyState) return;\n    this.resetPingTimeout();\n  }\n  /**\n   * Sets and resets ping timeout timer based on server pings.\n   *\n   * @api private\n   */\n\n\n  resetPingTimeout() {\n    this.clearTimeoutFn(this.pingTimeoutTimer);\n    this.pingTimeoutTimer = this.setTimeoutFn(() => {\n      this.onClose(\"ping timeout\");\n    }, this.pingInterval + this.pingTimeout);\n\n    if (this.opts.autoUnref) {\n      this.pingTimeoutTimer.unref();\n    }\n  }\n  /**\n   * Called on `drain` event\n   *\n   * @api private\n   */\n\n\n  onDrain() {\n    this.writeBuffer.splice(0, this.prevBufferLen); // setting prevBufferLen = 0 is very important\n    // for example, when upgrading, upgrade packet is sent over,\n    // and a nonzero prevBufferLen could cause problems on `drain`\n\n    this.prevBufferLen = 0;\n\n    if (0 === this.writeBuffer.length) {\n      this.emitReserved(\"drain\");\n    } else {\n      this.flush();\n    }\n  }\n  /**\n   * Flush write buffers.\n   *\n   * @api private\n   */\n\n\n  flush() {\n    if (\"closed\" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {\n      debug(\"flushing %d packets in socket\", this.writeBuffer.length);\n      this.transport.send(this.writeBuffer); // keep track of current length of writeBuffer\n      // splice writeBuffer and callbackBuffer on `drain`\n\n      this.prevBufferLen = this.writeBuffer.length;\n      this.emitReserved(\"flush\");\n    }\n  }\n  /**\n   * Sends a message.\n   *\n   * @param {String} message.\n   * @param {Function} callback function.\n   * @param {Object} options.\n   * @return {Socket} for chaining.\n   * @api public\n   */\n\n\n  write(msg, options, fn) {\n    this.sendPacket(\"message\", msg, options, fn);\n    return this;\n  }\n\n  send(msg, options, fn) {\n    this.sendPacket(\"message\", msg, options, fn);\n    return this;\n  }\n  /**\n   * Sends a packet.\n   *\n   * @param {String} packet type.\n   * @param {String} data.\n   * @param {Object} options.\n   * @param {Function} callback function.\n   * @api private\n   */\n\n\n  sendPacket(type, data, options, fn) {\n    if (\"function\" === typeof data) {\n      fn = data;\n      data = undefined;\n    }\n\n    if (\"function\" === typeof options) {\n      fn = options;\n      options = null;\n    }\n\n    if (\"closing\" === this.readyState || \"closed\" === this.readyState) {\n      return;\n    }\n\n    options = options || {};\n    options.compress = false !== options.compress;\n    const packet = {\n      type: type,\n      data: data,\n      options: options\n    };\n    this.emitReserved(\"packetCreate\", packet);\n    this.writeBuffer.push(packet);\n    if (fn) this.once(\"flush\", fn);\n    this.flush();\n  }\n  /**\n   * Closes the connection.\n   *\n   * @api public\n   */\n\n\n  close() {\n    const close = () => {\n      this.onClose(\"forced close\");\n      debug(\"socket closing - telling transport to close\");\n      this.transport.close();\n    };\n\n    const cleanupAndClose = () => {\n      this.off(\"upgrade\", cleanupAndClose);\n      this.off(\"upgradeError\", cleanupAndClose);\n      close();\n    };\n\n    const waitForUpgrade = () => {\n      // wait for upgrade to finish since we can't send packets while pausing a transport\n      this.once(\"upgrade\", cleanupAndClose);\n      this.once(\"upgradeError\", cleanupAndClose);\n    };\n\n    if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n      this.readyState = \"closing\";\n\n      if (this.writeBuffer.length) {\n        this.once(\"drain\", () => {\n          if (this.upgrading) {\n            waitForUpgrade();\n          } else {\n            close();\n          }\n        });\n      } else if (this.upgrading) {\n        waitForUpgrade();\n      } else {\n        close();\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Called upon transport error\n   *\n   * @api private\n   */\n\n\n  onError(err) {\n    debug(\"socket error %j\", err);\n    Socket.priorWebsocketSuccess = false;\n    this.emitReserved(\"error\", err);\n    this.onClose(\"transport error\", err);\n  }\n  /**\n   * Called upon transport close.\n   *\n   * @api private\n   */\n\n\n  onClose(reason, desc) {\n    if (\"opening\" === this.readyState || \"open\" === this.readyState || \"closing\" === this.readyState) {\n      debug('socket close with reason: \"%s\"', reason); // clear timers\n\n      this.clearTimeoutFn(this.pingTimeoutTimer); // stop event from firing again for transport\n\n      this.transport.removeAllListeners(\"close\"); // ensure transport won't stay open\n\n      this.transport.close(); // ignore further transport communication\n\n      this.transport.removeAllListeners();\n\n      if (typeof removeEventListener === \"function\") {\n        removeEventListener(\"offline\", this.offlineEventListener, false);\n      } // set ready state\n\n\n      this.readyState = \"closed\"; // clear session id\n\n      this.id = null; // emit close event\n\n      this.emitReserved(\"close\", reason, desc); // clean buffers after, so users can still\n      // grab the buffers on `close` event\n\n      this.writeBuffer = [];\n      this.prevBufferLen = 0;\n    }\n  }\n  /**\n   * Filters upgrades, returning only those matching client transports.\n   *\n   * @param {Array} server upgrades\n   * @api private\n   *\n   */\n\n\n  filterUpgrades(upgrades) {\n    const filteredUpgrades = [];\n    let i = 0;\n    const j = upgrades.length;\n\n    for (; i < j; i++) {\n      if (~this.transports.indexOf(upgrades[i])) filteredUpgrades.push(upgrades[i]);\n    }\n\n    return filteredUpgrades;\n  }\n\n}\nSocket.protocol = protocol;\n\nfunction clone(obj) {\n  const o = {};\n\n  for (let i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      o[i] = obj[i];\n    }\n  }\n\n  return o;\n}","import { Socket } from \"./socket.js\";\nexport { Socket };\nexport const protocol = Socket.protocol;\nexport { Transport } from \"./transport.js\";\nexport { transports } from \"./transports/index.js\";\nexport { installTimerFunctions } from \"./util.js\";","const withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n\nconst isView = obj => {\n  return typeof ArrayBuffer.isView === \"function\" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;\n};\n\nconst toString = Object.prototype.toString;\nconst withNativeBlob = typeof Blob === \"function\" || typeof Blob !== \"undefined\" && toString.call(Blob) === \"[object BlobConstructor]\";\nconst withNativeFile = typeof File === \"function\" || typeof File !== \"undefined\" && toString.call(File) === \"[object FileConstructor]\";\n/**\n * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.\n *\n * @private\n */\n\nexport function isBinary(obj) {\n  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;\n}\nexport function hasBinary(obj, toJSON) {\n  if (!obj || typeof obj !== \"object\") {\n    return false;\n  }\n\n  if (Array.isArray(obj)) {\n    for (let i = 0, l = obj.length; i < l; i++) {\n      if (hasBinary(obj[i])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  if (isBinary(obj)) {\n    return true;\n  }\n\n  if (obj.toJSON && typeof obj.toJSON === \"function\" && arguments.length === 1) {\n    return hasBinary(obj.toJSON(), true);\n  }\n\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n      return true;\n    }\n  }\n\n  return false;\n}","import { isBinary } from \"./is-binary.js\";\n/**\n * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @public\n */\n\nexport function deconstructPacket(packet) {\n  const buffers = [];\n  const packetData = packet.data;\n  const pack = packet;\n  pack.data = _deconstructPacket(packetData, buffers);\n  pack.attachments = buffers.length; // number of binary 'attachments'\n\n  return {\n    packet: pack,\n    buffers: buffers\n  };\n}\n\nfunction _deconstructPacket(data, buffers) {\n  if (!data) return data;\n\n  if (isBinary(data)) {\n    const placeholder = {\n      _placeholder: true,\n      num: buffers.length\n    };\n    buffers.push(data);\n    return placeholder;\n  } else if (Array.isArray(data)) {\n    const newData = new Array(data.length);\n\n    for (let i = 0; i < data.length; i++) {\n      newData[i] = _deconstructPacket(data[i], buffers);\n    }\n\n    return newData;\n  } else if (typeof data === \"object\" && !(data instanceof Date)) {\n    const newData = {};\n\n    for (const key in data) {\n      if (data.hasOwnProperty(key)) {\n        newData[key] = _deconstructPacket(data[key], buffers);\n      }\n    }\n\n    return newData;\n  }\n\n  return data;\n}\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @public\n */\n\n\nexport function reconstructPacket(packet, buffers) {\n  packet.data = _reconstructPacket(packet.data, buffers);\n  packet.attachments = undefined; // no longer useful\n\n  return packet;\n}\n\nfunction _reconstructPacket(data, buffers) {\n  if (!data) return data;\n\n  if (data && data._placeholder) {\n    return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n  } else if (Array.isArray(data)) {\n    for (let i = 0; i < data.length; i++) {\n      data[i] = _reconstructPacket(data[i], buffers);\n    }\n  } else if (typeof data === \"object\") {\n    for (const key in data) {\n      if (data.hasOwnProperty(key)) {\n        data[key] = _reconstructPacket(data[key], buffers);\n      }\n    }\n  }\n\n  return data;\n}","import { Emitter } from \"@socket.io/component-emitter\";\nimport { deconstructPacket, reconstructPacket } from \"./binary.js\";\nimport { isBinary, hasBinary } from \"./is-binary.js\";\nimport debugModule from \"debug\"; // debug()\n\nconst debug = debugModule(\"socket.io-parser\"); // debug()\n\n/**\n * Protocol version.\n *\n * @public\n */\n\nexport const protocol = 5;\nexport var PacketType;\n\n(function (PacketType) {\n  PacketType[PacketType[\"CONNECT\"] = 0] = \"CONNECT\";\n  PacketType[PacketType[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\n  PacketType[PacketType[\"EVENT\"] = 2] = \"EVENT\";\n  PacketType[PacketType[\"ACK\"] = 3] = \"ACK\";\n  PacketType[PacketType[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\n  PacketType[PacketType[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\n  PacketType[PacketType[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\n})(PacketType || (PacketType = {}));\n/**\n * A socket.io Encoder instance\n */\n\n\nexport class Encoder {\n  /**\n   * Encode a packet as a single string if non-binary, or as a\n   * buffer sequence, depending on packet type.\n   *\n   * @param {Object} obj - packet object\n   */\n  encode(obj) {\n    debug(\"encoding packet %j\", obj);\n\n    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\n      if (hasBinary(obj)) {\n        obj.type = obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK;\n        return this.encodeAsBinary(obj);\n      }\n    }\n\n    return [this.encodeAsString(obj)];\n  }\n  /**\n   * Encode packet as string.\n   */\n\n\n  encodeAsString(obj) {\n    // first is type\n    let str = \"\" + obj.type; // attachments if we have them\n\n    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {\n      str += obj.attachments + \"-\";\n    } // if we have a namespace other than `/`\n    // we append it followed by a comma `,`\n\n\n    if (obj.nsp && \"/\" !== obj.nsp) {\n      str += obj.nsp + \",\";\n    } // immediately followed by the id\n\n\n    if (null != obj.id) {\n      str += obj.id;\n    } // json data\n\n\n    if (null != obj.data) {\n      str += JSON.stringify(obj.data);\n    }\n\n    debug(\"encoded %j as %s\", obj, str);\n    return str;\n  }\n  /**\n   * Encode packet as 'buffer sequence' by removing blobs, and\n   * deconstructing packet into object with placeholders and\n   * a list of buffers.\n   */\n\n\n  encodeAsBinary(obj) {\n    const deconstruction = deconstructPacket(obj);\n    const pack = this.encodeAsString(deconstruction.packet);\n    const buffers = deconstruction.buffers;\n    buffers.unshift(pack); // add packet info to beginning of data list\n\n    return buffers; // write all the buffers\n  }\n\n}\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n */\n\nexport class Decoder extends Emitter {\n  constructor() {\n    super();\n  }\n  /**\n   * Decodes an encoded packet string into packet JSON.\n   *\n   * @param {String} obj - encoded packet\n   */\n\n\n  add(obj) {\n    let packet;\n\n    if (typeof obj === \"string\") {\n      packet = this.decodeString(obj);\n\n      if (packet.type === PacketType.BINARY_EVENT || packet.type === PacketType.BINARY_ACK) {\n        // binary packet's json\n        this.reconstructor = new BinaryReconstructor(packet); // no attachments, labeled binary but no binary data to follow\n\n        if (packet.attachments === 0) {\n          super.emitReserved(\"decoded\", packet);\n        }\n      } else {\n        // non-binary full packet\n        super.emitReserved(\"decoded\", packet);\n      }\n    } else if (isBinary(obj) || obj.base64) {\n      // raw binary data\n      if (!this.reconstructor) {\n        throw new Error(\"got binary data when not reconstructing a packet\");\n      } else {\n        packet = this.reconstructor.takeBinaryData(obj);\n\n        if (packet) {\n          // received final buffer\n          this.reconstructor = null;\n          super.emitReserved(\"decoded\", packet);\n        }\n      }\n    } else {\n      throw new Error(\"Unknown type: \" + obj);\n    }\n  }\n  /**\n   * Decode a packet String (JSON data)\n   *\n   * @param {String} str\n   * @return {Object} packet\n   */\n\n\n  decodeString(str) {\n    let i = 0; // look up type\n\n    const p = {\n      type: Number(str.charAt(0))\n    };\n\n    if (PacketType[p.type] === undefined) {\n      throw new Error(\"unknown packet type \" + p.type);\n    } // look up attachments if type binary\n\n\n    if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {\n      const start = i + 1;\n\n      while (str.charAt(++i) !== \"-\" && i != str.length) {}\n\n      const buf = str.substring(start, i);\n\n      if (buf != Number(buf) || str.charAt(i) !== \"-\") {\n        throw new Error(\"Illegal attachments\");\n      }\n\n      p.attachments = Number(buf);\n    } // look up namespace (if any)\n\n\n    if (\"/\" === str.charAt(i + 1)) {\n      const start = i + 1;\n\n      while (++i) {\n        const c = str.charAt(i);\n        if (\",\" === c) break;\n        if (i === str.length) break;\n      }\n\n      p.nsp = str.substring(start, i);\n    } else {\n      p.nsp = \"/\";\n    } // look up id\n\n\n    const next = str.charAt(i + 1);\n\n    if (\"\" !== next && Number(next) == next) {\n      const start = i + 1;\n\n      while (++i) {\n        const c = str.charAt(i);\n\n        if (null == c || Number(c) != c) {\n          --i;\n          break;\n        }\n\n        if (i === str.length) break;\n      }\n\n      p.id = Number(str.substring(start, i + 1));\n    } // look up json data\n\n\n    if (str.charAt(++i)) {\n      const payload = tryParse(str.substr(i));\n\n      if (Decoder.isPayloadValid(p.type, payload)) {\n        p.data = payload;\n      } else {\n        throw new Error(\"invalid payload\");\n      }\n    }\n\n    debug(\"decoded %s as %j\", str, p);\n    return p;\n  }\n\n  static isPayloadValid(type, payload) {\n    switch (type) {\n      case PacketType.CONNECT:\n        return typeof payload === \"object\";\n\n      case PacketType.DISCONNECT:\n        return payload === undefined;\n\n      case PacketType.CONNECT_ERROR:\n        return typeof payload === \"string\" || typeof payload === \"object\";\n\n      case PacketType.EVENT:\n      case PacketType.BINARY_EVENT:\n        return Array.isArray(payload) && payload.length > 0;\n\n      case PacketType.ACK:\n      case PacketType.BINARY_ACK:\n        return Array.isArray(payload);\n    }\n  }\n  /**\n   * Deallocates a parser's resources\n   */\n\n\n  destroy() {\n    if (this.reconstructor) {\n      this.reconstructor.finishedReconstruction();\n    }\n  }\n\n}\n\nfunction tryParse(str) {\n  try {\n    return JSON.parse(str);\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n */\n\n\nclass BinaryReconstructor {\n  constructor(packet) {\n    this.packet = packet;\n    this.buffers = [];\n    this.reconPack = packet;\n  }\n  /**\n   * Method to be called when binary data received from connection\n   * after a BINARY_EVENT packet.\n   *\n   * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n   * @return {null | Object} returns null if more binary data is expected or\n   *   a reconstructed packet object if all buffers have been received.\n   */\n\n\n  takeBinaryData(binData) {\n    this.buffers.push(binData);\n\n    if (this.buffers.length === this.reconPack.attachments) {\n      // done with buffer list\n      const packet = reconstructPacket(this.reconPack, this.buffers);\n      this.finishedReconstruction();\n      return packet;\n    }\n\n    return null;\n  }\n  /**\n   * Cleans up binary packet reconstruction variables.\n   */\n\n\n  finishedReconstruction() {\n    this.reconPack = null;\n    this.buffers = [];\n  }\n\n}","export function on(obj, ev, fn) {\n  obj.on(ev, fn);\n  return function subDestroy() {\n    obj.off(ev, fn);\n  };\n}","import { PacketType } from \"socket.io-parser\";\nimport { on } from \"./on.js\";\nimport { Emitter } from \"@socket.io/component-emitter\";\nimport debugModule from \"debug\"; // debug()\n\nconst debug = debugModule(\"socket.io-client:socket\"); // debug()\n\n/**\n * Internal events.\n * These events can't be emitted by the user.\n */\n\nconst RESERVED_EVENTS = Object.freeze({\n  connect: 1,\n  connect_error: 1,\n  disconnect: 1,\n  disconnecting: 1,\n  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n  newListener: 1,\n  removeListener: 1\n});\nexport class Socket extends Emitter {\n  /**\n   * `Socket` constructor.\n   *\n   * @public\n   */\n  constructor(io, nsp, opts) {\n    super();\n    this.connected = false;\n    this.disconnected = true;\n    this.receiveBuffer = [];\n    this.sendBuffer = [];\n    this.ids = 0;\n    this.acks = {};\n    this.flags = {};\n    this.io = io;\n    this.nsp = nsp;\n\n    if (opts && opts.auth) {\n      this.auth = opts.auth;\n    }\n\n    if (this.io._autoConnect) this.open();\n  }\n  /**\n   * Subscribe to open, close and packet events\n   *\n   * @private\n   */\n\n\n  subEvents() {\n    if (this.subs) return;\n    const io = this.io;\n    this.subs = [on(io, \"open\", this.onopen.bind(this)), on(io, \"packet\", this.onpacket.bind(this)), on(io, \"error\", this.onerror.bind(this)), on(io, \"close\", this.onclose.bind(this))];\n  }\n  /**\n   * Whether the Socket will try to reconnect when its Manager connects or reconnects\n   */\n\n\n  get active() {\n    return !!this.subs;\n  }\n  /**\n   * \"Opens\" the socket.\n   *\n   * @public\n   */\n\n\n  connect() {\n    if (this.connected) return this;\n    this.subEvents();\n    if (!this.io[\"_reconnecting\"]) this.io.open(); // ensure open\n\n    if (\"open\" === this.io._readyState) this.onopen();\n    return this;\n  }\n  /**\n   * Alias for connect()\n   */\n\n\n  open() {\n    return this.connect();\n  }\n  /**\n   * Sends a `message` event.\n   *\n   * @return self\n   * @public\n   */\n\n\n  send(...args) {\n    args.unshift(\"message\");\n    this.emit.apply(this, args);\n    return this;\n  }\n  /**\n   * Override `emit`.\n   * If the event is in `events`, it's emitted normally.\n   *\n   * @return self\n   * @public\n   */\n\n\n  emit(ev, ...args) {\n    if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n      throw new Error('\"' + ev + '\" is a reserved event name');\n    }\n\n    args.unshift(ev);\n    const packet = {\n      type: PacketType.EVENT,\n      data: args\n    };\n    packet.options = {};\n    packet.options.compress = this.flags.compress !== false; // event ack callback\n\n    if (\"function\" === typeof args[args.length - 1]) {\n      const id = this.ids++;\n      debug(\"emitting packet with ack id %d\", id);\n      const ack = args.pop();\n\n      this._registerAckCallback(id, ack);\n\n      packet.id = id;\n    }\n\n    const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;\n    const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);\n\n    if (discardPacket) {\n      debug(\"discard packet as the transport is not currently writable\");\n    } else if (this.connected) {\n      this.packet(packet);\n    } else {\n      this.sendBuffer.push(packet);\n    }\n\n    this.flags = {};\n    return this;\n  }\n  /**\n   * @private\n   */\n\n\n  _registerAckCallback(id, ack) {\n    const timeout = this.flags.timeout;\n\n    if (timeout === undefined) {\n      this.acks[id] = ack;\n      return;\n    } // @ts-ignore\n\n\n    const timer = this.io.setTimeoutFn(() => {\n      delete this.acks[id];\n\n      for (let i = 0; i < this.sendBuffer.length; i++) {\n        if (this.sendBuffer[i].id === id) {\n          debug(\"removing packet with ack id %d from the buffer\", id);\n          this.sendBuffer.splice(i, 1);\n        }\n      }\n\n      debug(\"event with ack id %d has timed out after %d ms\", id, timeout);\n      ack.call(this, new Error(\"operation has timed out\"));\n    }, timeout);\n\n    this.acks[id] = (...args) => {\n      // @ts-ignore\n      this.io.clearTimeoutFn(timer);\n      ack.apply(this, [null, ...args]);\n    };\n  }\n  /**\n   * Sends a packet.\n   *\n   * @param packet\n   * @private\n   */\n\n\n  packet(packet) {\n    packet.nsp = this.nsp;\n\n    this.io._packet(packet);\n  }\n  /**\n   * Called upon engine `open`.\n   *\n   * @private\n   */\n\n\n  onopen() {\n    debug(\"transport is open - connecting\");\n\n    if (typeof this.auth == \"function\") {\n      this.auth(data => {\n        this.packet({\n          type: PacketType.CONNECT,\n          data\n        });\n      });\n    } else {\n      this.packet({\n        type: PacketType.CONNECT,\n        data: this.auth\n      });\n    }\n  }\n  /**\n   * Called upon engine or manager `error`.\n   *\n   * @param err\n   * @private\n   */\n\n\n  onerror(err) {\n    if (!this.connected) {\n      this.emitReserved(\"connect_error\", err);\n    }\n  }\n  /**\n   * Called upon engine `close`.\n   *\n   * @param reason\n   * @private\n   */\n\n\n  onclose(reason) {\n    debug(\"close (%s)\", reason);\n    this.connected = false;\n    this.disconnected = true;\n    delete this.id;\n    this.emitReserved(\"disconnect\", reason);\n  }\n  /**\n   * Called with socket packet.\n   *\n   * @param packet\n   * @private\n   */\n\n\n  onpacket(packet) {\n    const sameNamespace = packet.nsp === this.nsp;\n    if (!sameNamespace) return;\n\n    switch (packet.type) {\n      case PacketType.CONNECT:\n        if (packet.data && packet.data.sid) {\n          const id = packet.data.sid;\n          this.onconnect(id);\n        } else {\n          this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n        }\n\n        break;\n\n      case PacketType.EVENT:\n        this.onevent(packet);\n        break;\n\n      case PacketType.BINARY_EVENT:\n        this.onevent(packet);\n        break;\n\n      case PacketType.ACK:\n        this.onack(packet);\n        break;\n\n      case PacketType.BINARY_ACK:\n        this.onack(packet);\n        break;\n\n      case PacketType.DISCONNECT:\n        this.ondisconnect();\n        break;\n\n      case PacketType.CONNECT_ERROR:\n        this.destroy();\n        const err = new Error(packet.data.message); // @ts-ignore\n\n        err.data = packet.data.data;\n        this.emitReserved(\"connect_error\", err);\n        break;\n    }\n  }\n  /**\n   * Called upon a server event.\n   *\n   * @param packet\n   * @private\n   */\n\n\n  onevent(packet) {\n    const args = packet.data || [];\n    debug(\"emitting event %j\", args);\n\n    if (null != packet.id) {\n      debug(\"attaching ack callback to event\");\n      args.push(this.ack(packet.id));\n    }\n\n    if (this.connected) {\n      this.emitEvent(args);\n    } else {\n      this.receiveBuffer.push(Object.freeze(args));\n    }\n  }\n\n  emitEvent(args) {\n    if (this._anyListeners && this._anyListeners.length) {\n      const listeners = this._anyListeners.slice();\n\n      for (const listener of listeners) {\n        listener.apply(this, args);\n      }\n    }\n\n    super.emit.apply(this, args);\n  }\n  /**\n   * Produces an ack callback to emit with an event.\n   *\n   * @private\n   */\n\n\n  ack(id) {\n    const self = this;\n    let sent = false;\n    return function (...args) {\n      // prevent double callbacks\n      if (sent) return;\n      sent = true;\n      debug(\"sending ack %j\", args);\n      self.packet({\n        type: PacketType.ACK,\n        id: id,\n        data: args\n      });\n    };\n  }\n  /**\n   * Called upon a server acknowlegement.\n   *\n   * @param packet\n   * @private\n   */\n\n\n  onack(packet) {\n    const ack = this.acks[packet.id];\n\n    if (\"function\" === typeof ack) {\n      debug(\"calling ack %s with %j\", packet.id, packet.data);\n      ack.apply(this, packet.data);\n      delete this.acks[packet.id];\n    } else {\n      debug(\"bad ack %s\", packet.id);\n    }\n  }\n  /**\n   * Called upon server connect.\n   *\n   * @private\n   */\n\n\n  onconnect(id) {\n    debug(\"socket connected with id %s\", id);\n    this.id = id;\n    this.connected = true;\n    this.disconnected = false;\n    this.emitBuffered();\n    this.emitReserved(\"connect\");\n  }\n  /**\n   * Emit buffered events (received and emitted).\n   *\n   * @private\n   */\n\n\n  emitBuffered() {\n    this.receiveBuffer.forEach(args => this.emitEvent(args));\n    this.receiveBuffer = [];\n    this.sendBuffer.forEach(packet => this.packet(packet));\n    this.sendBuffer = [];\n  }\n  /**\n   * Called upon server disconnect.\n   *\n   * @private\n   */\n\n\n  ondisconnect() {\n    debug(\"server disconnect (%s)\", this.nsp);\n    this.destroy();\n    this.onclose(\"io server disconnect\");\n  }\n  /**\n   * Called upon forced client/server side disconnections,\n   * this method ensures the manager stops tracking us and\n   * that reconnections don't get triggered for this.\n   *\n   * @private\n   */\n\n\n  destroy() {\n    if (this.subs) {\n      // clean subscriptions to avoid reconnections\n      this.subs.forEach(subDestroy => subDestroy());\n      this.subs = undefined;\n    }\n\n    this.io[\"_destroy\"](this);\n  }\n  /**\n   * Disconnects the socket manually.\n   *\n   * @return self\n   * @public\n   */\n\n\n  disconnect() {\n    if (this.connected) {\n      debug(\"performing disconnect (%s)\", this.nsp);\n      this.packet({\n        type: PacketType.DISCONNECT\n      });\n    } // remove socket from pool\n\n\n    this.destroy();\n\n    if (this.connected) {\n      // fire events\n      this.onclose(\"io client disconnect\");\n    }\n\n    return this;\n  }\n  /**\n   * Alias for disconnect()\n   *\n   * @return self\n   * @public\n   */\n\n\n  close() {\n    return this.disconnect();\n  }\n  /**\n   * Sets the compress flag.\n   *\n   * @param compress - if `true`, compresses the sending data\n   * @return self\n   * @public\n   */\n\n\n  compress(compress) {\n    this.flags.compress = compress;\n    return this;\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n   * ready to send messages.\n   *\n   * @returns self\n   * @public\n   */\n\n\n  get volatile() {\n    this.flags.volatile = true;\n    return this;\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n   * given number of milliseconds have elapsed without an acknowledgement from the server:\n   *\n   * ```\n   * socket.timeout(5000).emit(\"my-event\", (err) => {\n   *   if (err) {\n   *     // the server did not acknowledge the event in the given delay\n   *   }\n   * });\n   * ```\n   *\n   * @returns self\n   * @public\n   */\n\n\n  timeout(timeout) {\n    this.flags.timeout = timeout;\n    return this;\n  }\n  /**\n   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n   * callback.\n   *\n   * @param listener\n   * @public\n   */\n\n\n  onAny(listener) {\n    this._anyListeners = this._anyListeners || [];\n\n    this._anyListeners.push(listener);\n\n    return this;\n  }\n  /**\n   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n   * callback. The listener is added to the beginning of the listeners array.\n   *\n   * @param listener\n   * @public\n   */\n\n\n  prependAny(listener) {\n    this._anyListeners = this._anyListeners || [];\n\n    this._anyListeners.unshift(listener);\n\n    return this;\n  }\n  /**\n   * Removes the listener that will be fired when any event is emitted.\n   *\n   * @param listener\n   * @public\n   */\n\n\n  offAny(listener) {\n    if (!this._anyListeners) {\n      return this;\n    }\n\n    if (listener) {\n      const listeners = this._anyListeners;\n\n      for (let i = 0; i < listeners.length; i++) {\n        if (listener === listeners[i]) {\n          listeners.splice(i, 1);\n          return this;\n        }\n      }\n    } else {\n      this._anyListeners = [];\n    }\n\n    return this;\n  }\n  /**\n   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n   * e.g. to remove listeners.\n   *\n   * @public\n   */\n\n\n  listenersAny() {\n    return this._anyListeners || [];\n  }\n\n}","import { Socket as Engine, installTimerFunctions } from \"engine.io-client\";\nimport { Socket } from \"./socket.js\";\nimport * as parser from \"socket.io-parser\";\nimport { on } from \"./on.js\";\nimport Backoff from \"backo2\";\nimport { Emitter } from \"@socket.io/component-emitter\";\nimport debugModule from \"debug\"; // debug()\n\nconst debug = debugModule(\"socket.io-client:manager\"); // debug()\n\nexport class Manager extends Emitter {\n  constructor(uri, opts) {\n    var _a;\n\n    super();\n    this.nsps = {};\n    this.subs = [];\n\n    if (uri && \"object\" === typeof uri) {\n      opts = uri;\n      uri = undefined;\n    }\n\n    opts = opts || {};\n    opts.path = opts.path || \"/socket.io\";\n    this.opts = opts;\n    installTimerFunctions(this, opts);\n    this.reconnection(opts.reconnection !== false);\n    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n    this.reconnectionDelay(opts.reconnectionDelay || 1000);\n    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n    this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\n    this.backoff = new Backoff({\n      min: this.reconnectionDelay(),\n      max: this.reconnectionDelayMax(),\n      jitter: this.randomizationFactor()\n    });\n    this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n    this._readyState = \"closed\";\n    this.uri = uri;\n\n    const _parser = opts.parser || parser;\n\n    this.encoder = new _parser.Encoder();\n    this.decoder = new _parser.Decoder();\n    this._autoConnect = opts.autoConnect !== false;\n    if (this._autoConnect) this.open();\n  }\n\n  reconnection(v) {\n    if (!arguments.length) return this._reconnection;\n    this._reconnection = !!v;\n    return this;\n  }\n\n  reconnectionAttempts(v) {\n    if (v === undefined) return this._reconnectionAttempts;\n    this._reconnectionAttempts = v;\n    return this;\n  }\n\n  reconnectionDelay(v) {\n    var _a;\n\n    if (v === undefined) return this._reconnectionDelay;\n    this._reconnectionDelay = v;\n    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n    return this;\n  }\n\n  randomizationFactor(v) {\n    var _a;\n\n    if (v === undefined) return this._randomizationFactor;\n    this._randomizationFactor = v;\n    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n    return this;\n  }\n\n  reconnectionDelayMax(v) {\n    var _a;\n\n    if (v === undefined) return this._reconnectionDelayMax;\n    this._reconnectionDelayMax = v;\n    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n    return this;\n  }\n\n  timeout(v) {\n    if (!arguments.length) return this._timeout;\n    this._timeout = v;\n    return this;\n  }\n  /**\n   * Starts trying to reconnect if reconnection is enabled and we have not\n   * started reconnecting yet\n   *\n   * @private\n   */\n\n\n  maybeReconnectOnOpen() {\n    // Only try to reconnect if it's the first time we're connecting\n    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {\n      // keeps reconnection from firing twice for the same reconnection loop\n      this.reconnect();\n    }\n  }\n  /**\n   * Sets the current transport `socket`.\n   *\n   * @param {Function} fn - optional, callback\n   * @return self\n   * @public\n   */\n\n\n  open(fn) {\n    debug(\"readyState %s\", this._readyState);\n    if (~this._readyState.indexOf(\"open\")) return this;\n    debug(\"opening %s\", this.uri);\n    this.engine = new Engine(this.uri, this.opts);\n    const socket = this.engine;\n    const self = this;\n    this._readyState = \"opening\";\n    this.skipReconnect = false; // emit `open`\n\n    const openSubDestroy = on(socket, \"open\", function () {\n      self.onopen();\n      fn && fn();\n    }); // emit `error`\n\n    const errorSub = on(socket, \"error\", err => {\n      debug(\"error\");\n      self.cleanup();\n      self._readyState = \"closed\";\n      this.emitReserved(\"error\", err);\n\n      if (fn) {\n        fn(err);\n      } else {\n        // Only do this if there is no fn to handle the error\n        self.maybeReconnectOnOpen();\n      }\n    });\n\n    if (false !== this._timeout) {\n      const timeout = this._timeout;\n      debug(\"connect attempt will timeout after %d\", timeout);\n\n      if (timeout === 0) {\n        openSubDestroy(); // prevents a race condition with the 'open' event\n      } // set timer\n\n\n      const timer = this.setTimeoutFn(() => {\n        debug(\"connect attempt timed out after %d\", timeout);\n        openSubDestroy();\n        socket.close(); // @ts-ignore\n\n        socket.emit(\"error\", new Error(\"timeout\"));\n      }, timeout);\n\n      if (this.opts.autoUnref) {\n        timer.unref();\n      }\n\n      this.subs.push(function subDestroy() {\n        clearTimeout(timer);\n      });\n    }\n\n    this.subs.push(openSubDestroy);\n    this.subs.push(errorSub);\n    return this;\n  }\n  /**\n   * Alias for open()\n   *\n   * @return self\n   * @public\n   */\n\n\n  connect(fn) {\n    return this.open(fn);\n  }\n  /**\n   * Called upon transport open.\n   *\n   * @private\n   */\n\n\n  onopen() {\n    debug(\"open\"); // clear old subs\n\n    this.cleanup(); // mark as open\n\n    this._readyState = \"open\";\n    this.emitReserved(\"open\"); // add new subs\n\n    const socket = this.engine;\n    this.subs.push(on(socket, \"ping\", this.onping.bind(this)), on(socket, \"data\", this.ondata.bind(this)), on(socket, \"error\", this.onerror.bind(this)), on(socket, \"close\", this.onclose.bind(this)), on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n  }\n  /**\n   * Called upon a ping.\n   *\n   * @private\n   */\n\n\n  onping() {\n    this.emitReserved(\"ping\");\n  }\n  /**\n   * Called with data.\n   *\n   * @private\n   */\n\n\n  ondata(data) {\n    this.decoder.add(data);\n  }\n  /**\n   * Called when parser fully decodes a packet.\n   *\n   * @private\n   */\n\n\n  ondecoded(packet) {\n    this.emitReserved(\"packet\", packet);\n  }\n  /**\n   * Called upon socket error.\n   *\n   * @private\n   */\n\n\n  onerror(err) {\n    debug(\"error\", err);\n    this.emitReserved(\"error\", err);\n  }\n  /**\n   * Creates a new socket for the given `nsp`.\n   *\n   * @return {Socket}\n   * @public\n   */\n\n\n  socket(nsp, opts) {\n    let socket = this.nsps[nsp];\n\n    if (!socket) {\n      socket = new Socket(this, nsp, opts);\n      this.nsps[nsp] = socket;\n    }\n\n    return socket;\n  }\n  /**\n   * Called upon a socket close.\n   *\n   * @param socket\n   * @private\n   */\n\n\n  _destroy(socket) {\n    const nsps = Object.keys(this.nsps);\n\n    for (const nsp of nsps) {\n      const socket = this.nsps[nsp];\n\n      if (socket.active) {\n        debug(\"socket %s is still active, skipping close\", nsp);\n        return;\n      }\n    }\n\n    this._close();\n  }\n  /**\n   * Writes a packet.\n   *\n   * @param packet\n   * @private\n   */\n\n\n  _packet(packet) {\n    debug(\"writing packet %j\", packet);\n    const encodedPackets = this.encoder.encode(packet);\n\n    for (let i = 0; i < encodedPackets.length; i++) {\n      this.engine.write(encodedPackets[i], packet.options);\n    }\n  }\n  /**\n   * Clean up transport subscriptions and packet buffer.\n   *\n   * @private\n   */\n\n\n  cleanup() {\n    debug(\"cleanup\");\n    this.subs.forEach(subDestroy => subDestroy());\n    this.subs.length = 0;\n    this.decoder.destroy();\n  }\n  /**\n   * Close the current socket.\n   *\n   * @private\n   */\n\n\n  _close() {\n    debug(\"disconnect\");\n    this.skipReconnect = true;\n    this._reconnecting = false;\n    this.onclose(\"forced close\");\n    if (this.engine) this.engine.close();\n  }\n  /**\n   * Alias for close()\n   *\n   * @private\n   */\n\n\n  disconnect() {\n    return this._close();\n  }\n  /**\n   * Called upon engine close.\n   *\n   * @private\n   */\n\n\n  onclose(reason) {\n    debug(\"closed due to %s\", reason);\n    this.cleanup();\n    this.backoff.reset();\n    this._readyState = \"closed\";\n    this.emitReserved(\"close\", reason);\n\n    if (this._reconnection && !this.skipReconnect) {\n      this.reconnect();\n    }\n  }\n  /**\n   * Attempt a reconnection.\n   *\n   * @private\n   */\n\n\n  reconnect() {\n    if (this._reconnecting || this.skipReconnect) return this;\n    const self = this;\n\n    if (this.backoff.attempts >= this._reconnectionAttempts) {\n      debug(\"reconnect failed\");\n      this.backoff.reset();\n      this.emitReserved(\"reconnect_failed\");\n      this._reconnecting = false;\n    } else {\n      const delay = this.backoff.duration();\n      debug(\"will wait %dms before reconnect attempt\", delay);\n      this._reconnecting = true;\n      const timer = this.setTimeoutFn(() => {\n        if (self.skipReconnect) return;\n        debug(\"attempting reconnect\");\n        this.emitReserved(\"reconnect_attempt\", self.backoff.attempts); // check again for the case socket closed in above events\n\n        if (self.skipReconnect) return;\n        self.open(err => {\n          if (err) {\n            debug(\"reconnect attempt error\");\n            self._reconnecting = false;\n            self.reconnect();\n            this.emitReserved(\"reconnect_error\", err);\n          } else {\n            debug(\"reconnect success\");\n            self.onreconnect();\n          }\n        });\n      }, delay);\n\n      if (this.opts.autoUnref) {\n        timer.unref();\n      }\n\n      this.subs.push(function subDestroy() {\n        clearTimeout(timer);\n      });\n    }\n  }\n  /**\n   * Called upon successful reconnect.\n   *\n   * @private\n   */\n\n\n  onreconnect() {\n    const attempt = this.backoff.attempts;\n    this._reconnecting = false;\n    this.backoff.reset();\n    this.emitReserved(\"reconnect\", attempt);\n  }\n\n}","import { url } from \"./url.js\";\nimport { Manager } from \"./manager.js\";\nimport { Socket } from \"./socket.js\";\nimport debugModule from \"debug\"; // debug()\n\nconst debug = debugModule(\"socket.io-client\"); // debug()\n\n/**\n * Managers cache.\n */\n\nconst cache = {};\n\nfunction lookup(uri, opts) {\n  if (typeof uri === \"object\") {\n    opts = uri;\n    uri = undefined;\n  }\n\n  opts = opts || {};\n  const parsed = url(uri, opts.path || \"/socket.io\");\n  const source = parsed.source;\n  const id = parsed.id;\n  const path = parsed.path;\n  const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n  const newConnection = opts.forceNew || opts[\"force new connection\"] || false === opts.multiplex || sameNamespace;\n  let io;\n\n  if (newConnection) {\n    debug(\"ignoring socket cache for %s\", source);\n    io = new Manager(source, opts);\n  } else {\n    if (!cache[id]) {\n      debug(\"new io instance for %s\", source);\n      cache[id] = new Manager(source, opts);\n    }\n\n    io = cache[id];\n  }\n\n  if (parsed.query && !opts.query) {\n    opts.query = parsed.queryKey;\n  }\n\n  return io.socket(parsed.path, opts);\n} // so that \"lookup\" can be used both as a function (e.g. `io(...)`) and as a\n// namespace (e.g. `io.connect(...)`), for backward compatibility\n\n\nObject.assign(lookup, {\n  Manager,\n  Socket,\n  io: lookup,\n  connect: lookup\n});\n/**\n * Protocol version.\n *\n * @public\n */\n\nexport { protocol } from \"socket.io-parser\";\n/**\n * Expose constructors for standalone build.\n *\n * @public\n */\n\nexport { Manager, Socket, lookup as io, lookup as connect, lookup as default };","'use strict';\n\nconst os = require('os');\n\nconst hasFlag = require('has-flag');\n\nconst env = process.env;\nlet forceColor;\n\nif (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {\n  forceColor = false;\n} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {\n  forceColor = true;\n}\n\nif ('FORCE_COLOR' in env) {\n  forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;\n}\n\nfunction translateLevel(level) {\n  if (level === 0) {\n    return false;\n  }\n\n  return {\n    level,\n    hasBasic: true,\n    has256: level >= 2,\n    has16m: level >= 3\n  };\n}\n\nfunction supportsColor(stream) {\n  if (forceColor === false) {\n    return 0;\n  }\n\n  if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {\n    return 3;\n  }\n\n  if (hasFlag('color=256')) {\n    return 2;\n  }\n\n  if (stream && !stream.isTTY && forceColor !== true) {\n    return 0;\n  }\n\n  const min = forceColor ? 1 : 0;\n\n  if (process.platform === 'win32') {\n    // Node.js 7.5.0 is the first version of Node.js to include a patch to\n    // libuv that enables 256 color output on Windows. Anything earlier and it\n    // won't work. However, here we target Node.js 8 at minimum as it is an LTS\n    // release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows\n    // release that supports 256 colors. Windows 10 build 14931 is the first release\n    // that supports 16m/TrueColor.\n    const osRelease = os.release().split('.');\n\n    if (Number(process.versions.node.split('.')[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {\n      return Number(osRelease[2]) >= 14931 ? 3 : 2;\n    }\n\n    return 1;\n  }\n\n  if ('CI' in env) {\n    if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n      return 1;\n    }\n\n    return min;\n  }\n\n  if ('TEAMCITY_VERSION' in env) {\n    return /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n  }\n\n  if (env.COLORTERM === 'truecolor') {\n    return 3;\n  }\n\n  if ('TERM_PROGRAM' in env) {\n    const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n    switch (env.TERM_PROGRAM) {\n      case 'iTerm.app':\n        return version >= 3 ? 3 : 2;\n\n      case 'Apple_Terminal':\n        return 2;\n      // No default\n    }\n  }\n\n  if (/-256(color)?$/i.test(env.TERM)) {\n    return 2;\n  }\n\n  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n    return 1;\n  }\n\n  if ('COLORTERM' in env) {\n    return 1;\n  }\n\n  if (env.TERM === 'dumb') {\n    return min;\n  }\n\n  return min;\n}\n\nfunction getSupportLevel(stream) {\n  const level = supportsColor(stream);\n  return translateLevel(level);\n}\n\nmodule.exports = {\n  supportsColor: getSupportLevel,\n  stdout: getSupportLevel(process.stdout),\n  stderr: getSupportLevel(process.stderr)\n};","var v1 = require('./v1');\n\nvar v4 = require('./v4');\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\nmodule.exports = uuid;","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\n  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');\n}\n\nmodule.exports = bytesToUuid;","// Unique ID creation requires a high quality random # generator.  In node.js\n// this is pretty straight-forward - we use the crypto API.\nvar crypto = require('crypto');\n\nmodule.exports = function nodeRNG() {\n  return crypto.randomBytes(16);\n};","var rng = require('./lib/rng');\n\nvar bytesToUuid = require('./lib/bytesToUuid'); // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n\nvar _nodeId;\n\nvar _clockseq; // Previous uuid creation time\n\n\nvar _lastMSecs = 0;\nvar _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;","var rng = require('./lib/rng');\n\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof options == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;","/**\n * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.\n *\n * This can be used with JS designed for browsers to improve reuse of code and\n * allow the use of existing libraries.\n *\n * Usage: include(\"XMLHttpRequest.js\") and use XMLHttpRequest per W3C specs.\n *\n * @author Dan DeFelippi <dan@driverdan.com>\n * @contributor David Ellis <d.f.ellis@ieee.org>\n * @license MIT\n */\nvar fs = require('fs');\n\nvar Url = require('url');\n\nvar spawn = require('child_process').spawn;\n/**\n * Module exports.\n */\n\n\nmodule.exports = XMLHttpRequest; // backwards-compat\n\nXMLHttpRequest.XMLHttpRequest = XMLHttpRequest;\n/**\n * `XMLHttpRequest` constructor.\n *\n * Supported options for the `opts` object are:\n *\n *  - `agent`: An http.Agent instance; http.globalAgent may be used; if 'undefined', agent usage is disabled\n *\n * @param {Object} opts optional \"options\" object\n */\n\nfunction XMLHttpRequest(opts) {\n  \"use strict\";\n\n  opts = opts || {};\n  /**\n   * Private variables\n   */\n\n  var self = this;\n\n  var http = require('http');\n\n  var https = require('https'); // Holds http.js objects\n\n\n  var request;\n  var response; // Request settings\n\n  var settings = {}; // Disable header blacklist.\n  // Not part of XHR specs.\n\n  var disableHeaderCheck = false; // Set some default headers\n\n  var defaultHeaders = {\n    \"User-Agent\": \"node-XMLHttpRequest\",\n    \"Accept\": \"*/*\"\n  };\n  var headers = Object.assign({}, defaultHeaders); // These headers are not user setable.\n  // The following are allowed but banned in the spec:\n  // * user-agent\n\n  var forbiddenRequestHeaders = [\"accept-charset\", \"accept-encoding\", \"access-control-request-headers\", \"access-control-request-method\", \"connection\", \"content-length\", \"content-transfer-encoding\", \"cookie\", \"cookie2\", \"date\", \"expect\", \"host\", \"keep-alive\", \"origin\", \"referer\", \"te\", \"trailer\", \"transfer-encoding\", \"upgrade\", \"via\"]; // These request methods are not allowed\n\n  var forbiddenRequestMethods = [\"TRACE\", \"TRACK\", \"CONNECT\"]; // Send flag\n\n  var sendFlag = false; // Error flag, used when errors occur or abort is called\n\n  var errorFlag = false;\n  var abortedFlag = false; // Event listeners\n\n  var listeners = {};\n  /**\n   * Constants\n   */\n\n  this.UNSENT = 0;\n  this.OPENED = 1;\n  this.HEADERS_RECEIVED = 2;\n  this.LOADING = 3;\n  this.DONE = 4;\n  /**\n   * Public vars\n   */\n  // Current state\n\n  this.readyState = this.UNSENT; // default ready state change handler in case one is not set or is set late\n\n  this.onreadystatechange = null; // Result & response\n\n  this.responseText = \"\";\n  this.responseXML = \"\";\n  this.status = null;\n  this.statusText = null;\n  /**\n   * Private methods\n   */\n\n  /**\n   * Check if the specified header is allowed.\n   *\n   * @param string header Header to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n\n  var isAllowedHttpHeader = function (header) {\n    return disableHeaderCheck || header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1;\n  };\n  /**\n   * Check if the specified method is allowed.\n   *\n   * @param string method Request method to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n\n\n  var isAllowedHttpMethod = function (method) {\n    return method && forbiddenRequestMethods.indexOf(method) === -1;\n  };\n  /**\n   * Public methods\n   */\n\n  /**\n   * Open the connection. Currently supports local server requests.\n   *\n   * @param string method Connection method (eg GET, POST)\n   * @param string url URL for the connection.\n   * @param boolean async Asynchronous connection. Default is true.\n   * @param string user Username for basic authentication (optional)\n   * @param string password Password for basic authentication (optional)\n   */\n\n\n  this.open = function (method, url, async, user, password) {\n    this.abort();\n    errorFlag = false;\n    abortedFlag = false; // Check for valid request method\n\n    if (!isAllowedHttpMethod(method)) {\n      throw new Error(\"SecurityError: Request method not allowed\");\n    }\n\n    settings = {\n      \"method\": method,\n      \"url\": url.toString(),\n      \"async\": typeof async !== \"boolean\" ? true : async,\n      \"user\": user || null,\n      \"password\": password || null\n    };\n    setState(this.OPENED);\n  };\n  /**\n   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.\n   * This does not conform to the W3C spec.\n   *\n   * @param boolean state Enable or disable header checking.\n   */\n\n\n  this.setDisableHeaderCheck = function (state) {\n    disableHeaderCheck = state;\n  };\n  /**\n   * Sets a header for the request.\n   *\n   * @param string header Header name\n   * @param string value Header value\n   * @return boolean Header added\n   */\n\n\n  this.setRequestHeader = function (header, value) {\n    if (this.readyState != this.OPENED) {\n      throw new Error(\"INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN\");\n    }\n\n    if (!isAllowedHttpHeader(header)) {\n      console.warn('Refused to set unsafe header \"' + header + '\"');\n      return false;\n    }\n\n    if (sendFlag) {\n      throw new Error(\"INVALID_STATE_ERR: send flag is true\");\n    }\n\n    headers[header] = value;\n    return true;\n  };\n  /**\n   * Gets a header from the server response.\n   *\n   * @param string header Name of header to get.\n   * @return string Text of the header or null if it doesn't exist.\n   */\n\n\n  this.getResponseHeader = function (header) {\n    if (typeof header === \"string\" && this.readyState > this.OPENED && response.headers[header.toLowerCase()] && !errorFlag) {\n      return response.headers[header.toLowerCase()];\n    }\n\n    return null;\n  };\n  /**\n   * Gets all the response headers.\n   *\n   * @return string A string with all response headers separated by CR+LF\n   */\n\n\n  this.getAllResponseHeaders = function () {\n    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {\n      return \"\";\n    }\n\n    var result = \"\";\n\n    for (var i in response.headers) {\n      // Cookie headers are excluded\n      if (i !== \"set-cookie\" && i !== \"set-cookie2\") {\n        result += i + \": \" + response.headers[i] + \"\\r\\n\";\n      }\n    }\n\n    return result.substr(0, result.length - 2);\n  };\n  /**\n   * Gets a request header\n   *\n   * @param string name Name of header to get\n   * @return string Returns the request header or empty string if not set\n   */\n\n\n  this.getRequestHeader = function (name) {\n    // @TODO Make this case insensitive\n    if (typeof name === \"string\" && headers[name]) {\n      return headers[name];\n    }\n\n    return \"\";\n  };\n  /**\n   * Sends the request to the server.\n   *\n   * @param string data Optional data to send as request body.\n   */\n\n\n  this.send = function (data) {\n    if (this.readyState != this.OPENED) {\n      throw new Error(\"INVALID_STATE_ERR: connection must be opened before send() is called\");\n    }\n\n    if (sendFlag) {\n      throw new Error(\"INVALID_STATE_ERR: send has already been called\");\n    }\n\n    var ssl = false,\n        local = false;\n    var url = Url.parse(settings.url);\n    var host; // Determine the server\n\n    switch (url.protocol) {\n      case 'https:':\n        ssl = true;\n      // SSL & non-SSL both need host, no break here.\n\n      case 'http:':\n        host = url.hostname;\n        break;\n\n      case 'file:':\n        local = true;\n        break;\n\n      case undefined:\n      case '':\n        host = \"localhost\";\n        break;\n\n      default:\n        throw new Error(\"Protocol not supported.\");\n    } // Load files off the local filesystem (file://)\n\n\n    if (local) {\n      if (settings.method !== \"GET\") {\n        throw new Error(\"XMLHttpRequest: Only GET method is supported\");\n      }\n\n      if (settings.async) {\n        fs.readFile(unescape(url.pathname), 'utf8', function (error, data) {\n          if (error) {\n            self.handleError(error, error.errno || -1);\n          } else {\n            self.status = 200;\n            self.responseText = data;\n            setState(self.DONE);\n          }\n        });\n      } else {\n        try {\n          this.responseText = fs.readFileSync(unescape(url.pathname), 'utf8');\n          this.status = 200;\n          setState(self.DONE);\n        } catch (e) {\n          this.handleError(e, e.errno || -1);\n        }\n      }\n\n      return;\n    } // Default to port 80. If accessing localhost on another port be sure\n    // to use http://localhost:port/path\n\n\n    var port = url.port || (ssl ? 443 : 80); // Add query string if one is used\n\n    var uri = url.pathname + (url.search ? url.search : ''); // Set the Host header or the server may reject the request\n\n    headers[\"Host\"] = host;\n\n    if (!(ssl && port === 443 || port === 80)) {\n      headers[\"Host\"] += ':' + url.port;\n    } // Set Basic Auth if necessary\n\n\n    if (settings.user) {\n      if (typeof settings.password == \"undefined\") {\n        settings.password = \"\";\n      }\n\n      var authBuf = new Buffer(settings.user + \":\" + settings.password);\n      headers[\"Authorization\"] = \"Basic \" + authBuf.toString(\"base64\");\n    } // Set content length header\n\n\n    if (settings.method === \"GET\" || settings.method === \"HEAD\") {\n      data = null;\n    } else if (data) {\n      headers[\"Content-Length\"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);\n\n      if (!headers[\"Content-Type\"]) {\n        headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n      }\n    } else if (settings.method === \"POST\") {\n      // For a post with no data set Content-Length: 0.\n      // This is required by buggy servers that don't meet the specs.\n      headers[\"Content-Length\"] = 0;\n    }\n\n    var agent = opts.agent || false;\n    var options = {\n      host: host,\n      port: port,\n      path: uri,\n      method: settings.method,\n      headers: headers,\n      agent: agent\n    };\n\n    if (ssl) {\n      options.pfx = opts.pfx;\n      options.key = opts.key;\n      options.passphrase = opts.passphrase;\n      options.cert = opts.cert;\n      options.ca = opts.ca;\n      options.ciphers = opts.ciphers;\n      options.rejectUnauthorized = opts.rejectUnauthorized === false ? false : true;\n    } // Reset error flag\n\n\n    errorFlag = false; // Handle async requests\n\n    if (settings.async) {\n      // Use the proper protocol\n      var doRequest = ssl ? https.request : http.request; // Request is being sent, set send flag\n\n      sendFlag = true; // As per spec, this is called here for historical reasons.\n\n      self.dispatchEvent(\"readystatechange\"); // Handler for the response\n\n      var responseHandler = function (resp) {\n        // Set response var to the response we got back\n        // This is so it remains accessable outside this scope\n        response = resp; // Check for redirect\n        // @TODO Prevent looped redirects\n\n        if (response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {\n          // Change URL to the redirect location\n          settings.url = response.headers.location;\n          var url = Url.parse(settings.url); // Set host var in case it's used later\n\n          host = url.hostname; // Options for the new request\n\n          var newOptions = {\n            hostname: url.hostname,\n            port: url.port,\n            path: url.path,\n            method: response.statusCode === 303 ? 'GET' : settings.method,\n            headers: headers\n          };\n\n          if (ssl) {\n            newOptions.pfx = opts.pfx;\n            newOptions.key = opts.key;\n            newOptions.passphrase = opts.passphrase;\n            newOptions.cert = opts.cert;\n            newOptions.ca = opts.ca;\n            newOptions.ciphers = opts.ciphers;\n            newOptions.rejectUnauthorized = opts.rejectUnauthorized === false ? false : true;\n          } // Issue the new request\n\n\n          request = doRequest(newOptions, responseHandler).on('error', errorHandler);\n          request.end(); // @TODO Check if an XHR event needs to be fired here\n\n          return;\n        }\n\n        if (response && response.setEncoding) {\n          response.setEncoding(\"utf8\");\n        }\n\n        setState(self.HEADERS_RECEIVED);\n        self.status = response.statusCode;\n        response.on('data', function (chunk) {\n          // Make sure there's some data\n          if (chunk) {\n            self.responseText += chunk;\n          } // Don't emit state changes if the connection has been aborted.\n\n\n          if (sendFlag) {\n            setState(self.LOADING);\n          }\n        });\n        response.on('end', function () {\n          if (sendFlag) {\n            // The sendFlag needs to be set before setState is called.  Otherwise if we are chaining callbacks\n            // there can be a timing issue (the callback is called and a new call is made before the flag is reset).\n            sendFlag = false; // Discard the 'end' event if the connection has been aborted\n\n            setState(self.DONE);\n          }\n        });\n        response.on('error', function (error) {\n          self.handleError(error);\n        });\n      }; // Error handler for the request\n\n\n      var errorHandler = function (error) {\n        self.handleError(error);\n      }; // Create the request\n\n\n      request = doRequest(options, responseHandler).on('error', errorHandler);\n\n      if (opts.autoUnref) {\n        request.on('socket', socket => {\n          socket.unref();\n        });\n      } // Node 0.4 and later won't accept empty data. Make sure it's needed.\n\n\n      if (data) {\n        request.write(data);\n      }\n\n      request.end();\n      self.dispatchEvent(\"loadstart\");\n    } else {\n      // Synchronous\n      // Create a temporary file for communication with the other Node process\n      var contentFile = \".node-xmlhttprequest-content-\" + process.pid;\n      var syncFile = \".node-xmlhttprequest-sync-\" + process.pid;\n      fs.writeFileSync(syncFile, \"\", \"utf8\"); // The async request the other Node process executes\n\n      var execString = \"var http = require('http'), https = require('https'), fs = require('fs');\" + \"var doRequest = http\" + (ssl ? \"s\" : \"\") + \".request;\" + \"var options = \" + JSON.stringify(options) + \";\" + \"var responseText = '';\" + \"var req = doRequest(options, function(response) {\" + \"response.setEncoding('utf8');\" + \"response.on('data', function(chunk) {\" + \"  responseText += chunk;\" + \"});\" + \"response.on('end', function() {\" + \"fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-STATUS:' + response.statusCode + ',' + responseText, 'utf8');\" + \"fs.unlinkSync('\" + syncFile + \"');\" + \"});\" + \"response.on('error', function(error) {\" + \"fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');\" + \"fs.unlinkSync('\" + syncFile + \"');\" + \"});\" + \"}).on('error', function(error) {\" + \"fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');\" + \"fs.unlinkSync('\" + syncFile + \"');\" + \"});\" + (data ? \"req.write('\" + JSON.stringify(data).slice(1, -1).replace(/'/g, \"\\\\'\") + \"');\" : \"\") + \"req.end();\"; // Start the other Node Process, executing this string\n\n      var syncProc = spawn(process.argv[0], [\"-e\", execString]);\n      var statusText;\n\n      while (fs.existsSync(syncFile)) {// Wait while the sync file is empty\n      }\n\n      self.responseText = fs.readFileSync(contentFile, 'utf8'); // Kill the child process once the file has data\n\n      syncProc.stdin.end(); // Remove the temporary file\n\n      fs.unlinkSync(contentFile);\n\n      if (self.responseText.match(/^NODE-XMLHTTPREQUEST-ERROR:/)) {\n        // If the file returned an error, handle it\n        var errorObj = self.responseText.replace(/^NODE-XMLHTTPREQUEST-ERROR:/, \"\");\n        self.handleError(errorObj, 503);\n      } else {\n        // If the file returned okay, parse its data and move to the DONE state\n        self.status = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:([0-9]*),.*/, \"$1\");\n        self.responseText = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:[0-9]*,(.*)/, \"$1\");\n        setState(self.DONE);\n      }\n    }\n  };\n  /**\n   * Called when an error is encountered to deal with it.\n   * @param  status  {number}    HTTP status code to use rather than the default (0) for XHR errors.\n   */\n\n\n  this.handleError = function (error, status) {\n    this.status = status || 0;\n    this.statusText = error;\n    this.responseText = error.stack;\n    errorFlag = true;\n    setState(this.DONE);\n  };\n  /**\n   * Aborts a request.\n   */\n\n\n  this.abort = function () {\n    if (request) {\n      request.abort();\n      request = null;\n    }\n\n    headers = Object.assign({}, defaultHeaders);\n    this.responseText = \"\";\n    this.responseXML = \"\";\n    errorFlag = abortedFlag = true;\n\n    if (this.readyState !== this.UNSENT && (this.readyState !== this.OPENED || sendFlag) && this.readyState !== this.DONE) {\n      sendFlag = false;\n      setState(this.DONE);\n    }\n\n    this.readyState = this.UNSENT;\n  };\n  /**\n   * Adds an event listener. Preferred method of binding to events.\n   */\n\n\n  this.addEventListener = function (event, callback) {\n    if (!(event in listeners)) {\n      listeners[event] = [];\n    } // Currently allows duplicate callbacks. Should it?\n\n\n    listeners[event].push(callback);\n  };\n  /**\n   * Remove an event callback that has already been bound.\n   * Only works on the matching funciton, cannot be a copy.\n   */\n\n\n  this.removeEventListener = function (event, callback) {\n    if (event in listeners) {\n      // Filter will return a new array with the callback removed\n      listeners[event] = listeners[event].filter(function (ev) {\n        return ev !== callback;\n      });\n    }\n  };\n  /**\n   * Dispatch any events, including both \"on\" methods and events attached using addEventListener.\n   */\n\n\n  this.dispatchEvent = function (event) {\n    if (typeof self[\"on\" + event] === \"function\") {\n      if (this.readyState === this.DONE) setImmediate(function () {\n        self[\"on\" + event]();\n      });else self[\"on\" + event]();\n    }\n\n    if (event in listeners) {\n      for (let i = 0, len = listeners[event].length; i < len; i++) {\n        if (this.readyState === this.DONE) setImmediate(function () {\n          listeners[event][i].call(self);\n        });else listeners[event][i].call(self);\n      }\n    }\n  };\n  /**\n   * Changes readyState and calls onreadystatechange.\n   *\n   * @param int state New state\n   */\n\n\n  var setState = function (state) {\n    if (self.readyState === state || self.readyState === self.UNSENT && abortedFlag) return;\n    self.readyState = state;\n\n    if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {\n      self.dispatchEvent(\"readystatechange\");\n    }\n\n    if (self.readyState === self.DONE) {\n      let fire;\n      if (abortedFlag) fire = \"abort\";else if (errorFlag) fire = \"error\";else fire = \"load\";\n      self.dispatchEvent(fire); // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)\n\n      self.dispatchEvent(\"loadend\");\n    }\n  };\n}\n\n;","'use strict';\n\nvar alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),\n    length = 64,\n    map = {},\n    seed = 0,\n    i = 0,\n    prev;\n/**\n * Return a string representing the specified number.\n *\n * @param {Number} num The number to convert.\n * @returns {String} The string representation of the number.\n * @api public\n */\n\nfunction encode(num) {\n  var encoded = '';\n\n  do {\n    encoded = alphabet[num % length] + encoded;\n    num = Math.floor(num / length);\n  } while (num > 0);\n\n  return encoded;\n}\n/**\n * Return the integer value specified by the given string.\n *\n * @param {String} str The string to convert.\n * @returns {Number} The integer value represented by the string.\n * @api public\n */\n\n\nfunction decode(str) {\n  var decoded = 0;\n\n  for (i = 0; i < str.length; i++) {\n    decoded = decoded * length + map[str.charAt(i)];\n  }\n\n  return decoded;\n}\n/**\n * Yeast: A tiny growing id generator.\n *\n * @returns {String} A unique id.\n * @api public\n */\n\n\nfunction yeast() {\n  var now = encode(+new Date());\n  if (now !== prev) return seed = 0, prev = now;\n  return now + '.' + encode(seed++);\n} //\n// Map each character to its index.\n//\n\n\nfor (; i < length; i++) map[alphabet[i]] = i; //\n// Expose the `yeast`, `encode` and `decode` functions.\n//\n\n\nyeast.encode = encode;\nyeast.decode = decode;\nmodule.exports = yeast;","import AltrpModel from '../../../../editor/src/js/classes/AltrpModel';\r\nimport {togglePopup} from '../store/popup-trigger/actions';\r\nimport {sendEmail} from '../helpers/sendEmail';\r\nimport {changeCurrentModel} from \"../store/current-model/actions\";\r\nimport { v4 as uuid } from \"uuid\";\r\nimport { io } from \"socket.io-client\";\r\nimport axios from \"axios\";\r\nconst {\r\n  altrpLogin,\r\n  altrpLogout,\r\n  dataFromTable,\r\n  dataToCSV,\r\n  dataToXML,\r\n  elementsToPdf,\r\n  getAppContext,\r\n  getComponentByElementId,\r\n  getHTMLElementById,\r\n  parseParamsFromString,\r\n  getDataByPath,\r\n  printElements,\r\n  replaceContentWithData,\r\n  scrollToElement,\r\n  setDataByPath,\r\n  dataToXLS,\r\n  delay,\r\n  altrpCompare,\r\n  Resource,\r\n  getWrapperHTMLElementByElement\r\n} = window.altrpHelpers;\r\n\r\n// let  history = require('history');\r\n// // import {history} from 'history';\r\n// console.log(history.history);\r\n/**\r\n *     \r\n * @link https://docs.google.com/document/d/1v8Hm1DLkqqwzBeISd8-UvgTqscVxQPtBUtKqBrH1HaU/edit#\r\n * @class AltrpAction\r\n */\r\nclass AltrpAction extends AltrpModel {\r\n  constructor(data, widgetId, element) {\r\n    super(data);\r\n    this.setProperty('_widgetId', widgetId);\r\n    this.setProperty('_element', element);\r\n    this.init();\r\n  }\r\n\r\n  /**\r\n   *  id \r\n   * @return {string}\r\n   */\r\n  getElementId() {\r\n    return this.getProperty('_element').getId();\r\n  }\r\n\r\n  /**\r\n   *  id   \r\n   * @return {string}\r\n   */\r\n  getFormId() {\r\n    let formId = this.getProperty('form_id');\r\n    if (!formId) {\r\n      return formId;\r\n    }\r\n    if (formId.indexOf('{{') !== -1) {\r\n      formId = replaceContentWithData(formId, this.getCurrentModel().getData());\r\n    }\r\n    return formId;\r\n  }\r\n\r\n  /**\r\n   *  URL \r\n   * @return {string}\r\n   */\r\n  getFormURL() {\r\n    let formURL = this.getProperty('form_url');\r\n    if (!formURL) {\r\n      return formURL;\r\n    }\r\n    if (formURL.indexOf('{{') !== -1) {\r\n      formURL = replaceContentWithData(\r\n        formURL,\r\n        this.getCurrentModel().getData()\r\n      );\r\n    }\r\n    return formURL;\r\n  }\r\n\r\n  /**\r\n   *     \r\n   * @return {{}}\r\n   */\r\n  getWrapperComponent() {\r\n    return getComponentByElementId(this.getElementId());\r\n  }\r\n\r\n  /**\r\n   *   \r\n   * @return {FrontElement | null}\r\n   */\r\n  getElement() {\r\n    return this.getProperty('_element');\r\n  }\r\n\r\n  /**\r\n   *       \r\n   * @return {AltrpModel | null}\r\n   */\r\n  getCurrentModel() {\r\n    const element = this.getElement();\r\n    return element.getCurrentModel();\r\n  }\r\n\r\n  /**\r\n   *    name,   ,      \r\n   * @params {string} name\r\n   * @params {*} defaultValue\r\n   * @return {*}\r\n   */\r\n  getReplacedProperty(name, defaultValue = '') {\r\n    let value = this.getProperty(name, defaultValue);\r\n    if (_.isString(value)) {\r\n      value = replaceContentWithData(value, this.getCurrentModel().getData());\r\n    }\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   *  \r\n   */\r\n  async init() {\r\n    switch (this.getType()) {\r\n      case 'form': {\r\n        if (!this.getFormURL()) {\r\n          this.setProperty('_form', null);\r\n          return;\r\n        }\r\n        // const formsManager = (\r\n        //   await import(\r\n        //     '../../../../editor/src/js/classes/modules/FormsManager.js'\r\n        //   )\r\n        // ).default;\r\n        // const formOptions = {\r\n        //   dynamicURL: true,\r\n        //   customRoute: this.getFormURL()\r\n        // };\r\n\r\n        // const form = formsManager.registerForm(\r\n        //   this.getFormId(),\r\n        //   '',\r\n        //   this.getProperty('form_method'),\r\n        //   formOptions\r\n        // );\r\n        // this.setProperty('_form', form);\r\n        return;\r\n      }\r\n      case 'login': {\r\n        const form = formsManager.registerForm(\r\n          this.getFormId(),\r\n          'login',\r\n          'POST'\r\n        );\r\n        this.setProperty('_form', form);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   *   \r\n   * @return {string}\r\n   */\r\n  getType() {\r\n    return this.getProperty('type');\r\n  }\r\n\r\n  /**\r\n   *   \r\n   * @return {*}\r\n   */\r\n  setType(type) {\r\n    return this.setProperty('type', type);\r\n  }\r\n\r\n  /**\r\n   *   \r\n   * @return {Promise<void>}\r\n   */\r\n  async doAction() {\r\n    let result = {\r\n      success: false\r\n    };\r\n    let confirmText = this.getProperty('confirm');\r\n    confirmText = replaceContentWithData(confirmText, this.getCurrentModel().getData());\r\n\r\n    if (confirmText && !confirm(confirmText)) {\r\n      return {\r\n        success: false,\r\n        message: 'User not Confirm'\r\n      };\r\n    }\r\n    switch (this.getType()) {\r\n      case 'form': {\r\n        result = await this.doActionForm();\r\n      }\r\n        break;\r\n      case 'delay': {\r\n        result = await this.doActionDelay();\r\n      }\r\n        break;\r\n      case 'email': {\r\n        result = await this.doActionEmail();\r\n      }\r\n        break;\r\n      case 'redirect': {\r\n        result = await this.doActionRedirect();\r\n      }\r\n        break;\r\n      case 'toggle_element': {\r\n        result = await this.doActionToggleElements();\r\n      }\r\n        break;\r\n      case 'toggle_popup': {\r\n        result = await this.doActionTogglePopup();\r\n      }\r\n        break;\r\n      case 'print_page': {\r\n        result = await this.doActionPrintPage();\r\n      }\r\n        break;\r\n      case 'print_elements': {\r\n        result = await this.doActionPrintElements();\r\n      }\r\n        break;\r\n      case 'scroll_to_element': {\r\n        result = await this.doActionScrollToElement();\r\n      }\r\n        break;\r\n      case 'scroll_to_top': {\r\n        result = await this.doActionScrollToTop();\r\n      }\r\n        break;\r\n      case 'scroll_to_bottom': {\r\n        result = await this.doActionScrollToBottom();\r\n      }\r\n        break;\r\n      case 'trigger': {\r\n        result = await this.doActionTrigger();\r\n      }\r\n        break;\r\n      case 'page_to_pdf': {\r\n        result = await this.doActionPageToPDF();\r\n      }\r\n        break;\r\n      case 'elements_to_pdf': {\r\n        result = await this.doActionElementsToPDF();\r\n      }\r\n        break;\r\n      case 'data_to_csv': {\r\n        result = await this.doActionDataToCSV();\r\n      }\r\n        break;\r\n      case 'table_to_csv': {\r\n        result = await this.doActionTableToCSV();\r\n      }\r\n        break;\r\n      case 'table_to_xml': {\r\n        result = await this.doActionTableToXML();\r\n      }\r\n        break;\r\n      case 'table_to_xls':\r\n        result = await this.doActionTableToXLS();\r\n        break;\r\n      case 'login': {\r\n        result = await this.doActionLogin();\r\n      }\r\n        break;\r\n      case 'logout': {\r\n        result = await this.doActionLogout();\r\n      }\r\n        break;\r\n      case 'set_data': {\r\n        result = await this.doActionSetData();\r\n      }\r\n        break;\r\n      case 'update_current_datasources': {\r\n        result = await this.doActionUpdateCurrentDatasources();\r\n      }\r\n        break;\r\n      case 'update_current_model': {\r\n        result = await this.doActionUpdateCurrentModel();\r\n      }\r\n        break;\r\n      case 'forms_manipulate': {\r\n        result = await this.doActionFormsManipulate();\r\n      }\r\n        break;\r\n      case 'custom_code': {\r\n        result = await this.doActionCustomCode();\r\n      }\r\n        break;\r\n      case 'play_sound': {\r\n        result = await this.doActionPlaySound();\r\n      }\r\n        break;\r\n      case 'condition': {\r\n        result = await this.doActionCondition();\r\n      }\r\n        break;\r\n      case 'vi_toggle': {\r\n        result = await this.doActionVIToggle();\r\n      }\r\n        break;\r\n      case 'oauth': {\r\n        result = await this.doActionOAuth();\r\n      }\r\n        break;\r\n      case 'metamask_connect': {\r\n        result = await this.metaMaskConnect();\r\n      }\r\n        break;\r\n      case 'socket_emit': {\r\n        result = await this.doActionSocketEmit();\r\n\r\n      }\r\n        break;\r\n      case 'socket_receiver': {\r\n        result = this.doActionSocketReceiver();\r\n\r\n      }\r\n        break;\r\n    }\r\n    let alertText = '';\r\n    if (result.success) {\r\n      alertText = this.getProperty('alert');\r\n    } else {\r\n      alertText = this.getProperty('reject');\r\n    }\r\n    if (alertText) {\r\n      alertText = replaceContentWithData(alertText, this.getCurrentModel().getData());\r\n      alert(alertText);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   *    \r\n   * @return {object}\r\n   */\r\n  async doActionSocketEmit() {\r\n    // if(!window.io) {\r\n    //   window.io = io()\r\n    // }\r\n    let name = replaceContentWithData(this.getProperty(\"socket_emit_name\"), this.getCurrentModel().getData())\r\n\r\n    const value = {\r\n      name,\r\n      data: replaceContentWithData(this.getProperty(\"socket_value\"), this.getCurrentModel().getData())\r\n    }\r\n\r\n    console.log(value)\r\n    await axios.post(\"/sockets\", value)\r\n    return {\r\n      success: true\r\n    }\r\n  }\r\n\r\n  /**\r\n   *  \r\n   * @return {object}\r\n   */\r\n  doActionSocketReceiver() {\r\n    if(!window.io) {\r\n      window.io = io(`:${process.env.SOCKETS_KEY}`)\r\n      window\r\n    }\r\n\r\n    let name = \"\"\r\n\r\n    if(this.getProperty(\"socket_type\") === \"custom\") {\r\n      name = replaceContentWithData(this.getProperty(\"socket_name\"), this.getCurrentModel().getData());\r\n    } else {\r\n      const user = window.current_user\r\n\r\n      if(!user.is_guest && user.guid) {\r\n        name = user.guid\r\n      } else {\r\n        let guid = localStorage.getItem(\"socket_guid\");\r\n        if(!guid) {\r\n          localStorage.setItem(\"socket_guid\", uuid())\r\n          guid = localStorage.getItem(\"socket_guid\")\r\n        }\r\n\r\n        name = guid\r\n      }\r\n\r\n    }\r\n\r\n    console.log(name)\r\n    window.io.on(replaceContentWithData(name, this.getCurrentModel().getData()), (data) => {\r\n      console.log(data)\r\n    });\r\n\r\n    return {\r\n      success: true\r\n    }\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   *   -\r\n   * @return {Promise<{}>}\r\n   */\r\n  async doActionForm() {\r\n    // if (! this.getProperty('_form')) {\r\n    //   return {\r\n    //     success: false,\r\n    //     message: ' '\r\n    //   };\r\n    // }\r\n    const formsManager = (\r\n      await import(/* webpackChunkName: 'formsManager' */'../../../../editor/src/js/classes/modules/FormsManager.js')\r\n    ).default;\r\n\r\n    let data = null;\r\n    let customHeaders = null;\r\n    if (this.getProperty('custom_headers')) {\r\n      customHeaders = parseParamsFromString(\r\n        this.getProperty('custom_headers'),\r\n        this.getCurrentModel()\r\n      );\r\n    }\r\n    if (this.getProperty('data')) {\r\n      data = parseParamsFromString(\r\n        this.getProperty('data'),\r\n        getAppContext(this.getCurrentModel()),\r\n        true\r\n      );\r\n      // if (!_.isEmpty(data)) {\r\n      //   return form.submit('', '', data);\r\n      // }\r\n      // return { success: true };\r\n    }\r\n    if (this.getProperty('forms_bulk')) {\r\n      if (\r\n        _.isArray(getDataByPath(this.getProperty('bulk_path'))) &&\r\n        _.get(getDataByPath(this.getProperty('bulk_path')), 'length')\r\n      ) {\r\n        let bulk = getDataByPath(this.getProperty('bulk_path'));\r\n        /**\r\n         *      ,       getData\r\n         * @type {AltrpForm}\r\n         */\r\n        const form = formsManager.registerForm(\r\n          this.getFormId(),\r\n          '',\r\n          this.getProperty('form_method'),\r\n          {\r\n            customRoute: ''\r\n          }\r\n        );\r\n        data = _.assign(form.getData(), data);\r\n        let bulkRequests = bulk.map(async (item, idx) => {\r\n          if (this.getProperty('data')) {\r\n            data = parseParamsFromString(\r\n              this.getProperty('data'),\r\n              getAppContext(item),\r\n              true\r\n            );\r\n          }\r\n          let url = this.getProperty('form_url');\r\n          url = replaceContentWithData(url, item);\r\n          const form = formsManager.registerForm(\r\n            this.getFormId() + idx,\r\n            '',\r\n            this.getProperty('form_method'),\r\n            {\r\n              customRoute: url\r\n            }\r\n          );\r\n          return await form.submit('', '', data, customHeaders);\r\n        });\r\n        try {\r\n          let res = await Promise.all(bulkRequests);\r\n        } catch (error) {\r\n          console.error(error);\r\n          bulk.forEach((item, idx) => {\r\n            formsManager.deleteFormById(this.getFormId() + idx);\r\n          });\r\n          return {success: false};\r\n        }\r\n        bulk.forEach((item, idx) => {\r\n          formsManager.deleteFormById(this.getFormId() + idx);\r\n        });\r\n      }\r\n\r\n      return {success: true};\r\n    }\r\n    if (this.getProperty('path')) {\r\n      let _data = getDataByPath(this.getProperty('path'), {});\r\n      if (!_.isEmpty(_data)) {\r\n        data = _.assign(_data, data);\r\n      }\r\n    }\r\n    /**\r\n     *\r\n     * @type {AltrpForm}\r\n     */\r\n    // let form = this.getProperty('_form');\r\n    if (!this.getFormURL()) {\r\n      this.setProperty('_form', null);\r\n      return {\r\n        success: false\r\n      };\r\n    }\r\n    const formOptions = {\r\n      dynamicURL: true,\r\n      customRoute: this.getFormURL()\r\n    };\r\n    const form = formsManager.registerForm(\r\n      this.getFormId(),\r\n      '',\r\n      this.getProperty('form_method'),\r\n      formOptions\r\n    );\r\n    let result = {\r\n      success: true\r\n    };\r\n    try {\r\n      const response = await form.submit('', '', data, customHeaders);\r\n      result = _.assign(result, response);\r\n    } catch (error) {\r\n      console.error(error);\r\n      result.error = error;\r\n      result.success = false;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   *     form_url\r\n   * @return {Promise<{}>}\r\n   */\r\n  async doActionRedirect() {\r\n    let URL = this.getFormURL();\r\n    if(! URL){\r\n      return {\r\n        success: true\r\n      }\r\n    }\r\n    if (window.frontAppRouter) {\r\n      if (this.getProperty('back')) {\r\n        frontAppRouter.history.goBack();\r\n      } else {\r\n        let innerRedirect = !this.getProperty('outer');\r\n        if (innerRedirect) {\r\n          frontAppRouter.history.push(URL);\r\n        } else {\r\n          window.location.assign(URL);\r\n        }\r\n      }\r\n    } else {\r\n      if (this.getProperty('back')) {\r\n        history.back()\r\n      } else {\r\n        window.location.href = URL;\r\n      }\r\n    }\r\n    return {\r\n      success: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   * /    \r\n   * @return {Promise<{}>}\r\n   */\r\n  async doActionToggleElements() {\r\n    let IDs = this.getProperty('elements_ids');\r\n\r\n    if (!IDs) {\r\n      return {success: true};\r\n    }\r\n    IDs = IDs.split(',');\r\n\r\n    IDs.forEach(id => {\r\n      let component = getComponentByElementId(id);\r\n      if (!component && !component.toggleElementDisplay) {\r\n        return;\r\n      }\r\n      component.toggleElementDisplay();\r\n    });\r\n    return {\r\n      success: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   * / \r\n   * @return {Promise<{}>}\r\n   */\r\n  async doActionTogglePopup() {\r\n    let id = this.getProperty('popup_id');\r\n    if (!id) {\r\n      return {\r\n        success: true\r\n      };\r\n    }\r\n    if (window['h-altrp']) {\r\n      const loadPopups = (await import(/* webpackChunkName: 'load-popups' */\"../functions/load-popups\")).default;\r\n      await loadPopups();\r\n    }\r\n    appStore.dispatch(togglePopup(id));\r\n\r\n    return {\r\n      success: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   *  \r\n   * @return {Promise<{}>}\r\n   */\r\n  async doActionPrintPage() {\r\n    window.print();\r\n    return {\r\n      success: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   *  \r\n   * @return {Promise<{}>}\r\n   */\r\n  async doActionPrintElements() {\r\n    let IDs = this.getProperty('elements_ids');\r\n    if (!IDs) {\r\n      return {success: true};\r\n    }\r\n    IDs = IDs.split(',');\r\n    let elementsToPrint = [];\r\n    IDs.forEach(elementId => {\r\n      if (!elementId || !elementId.trim()) {\r\n        return;\r\n      }\r\n      getHTMLElementById(elementId.trim()) &&\r\n      elementsToPrint.push(getHTMLElementById(elementId));\r\n      if (getComponentByElementId(elementId.trim())?.getStylesHTMLElement) {\r\n        let stylesElement = getComponentByElementId(\r\n          elementId.trim()\r\n        ).getStylesHTMLElement();\r\n        if (stylesElement) {\r\n          elementsToPrint.push(stylesElement);\r\n        }\r\n      }\r\n    });\r\n    if (_.get(window, 'stylesModule.stylesContainer.current')) {\r\n      elementsToPrint.push(\r\n        _.get(window, 'stylesModule.stylesContainer.current')\r\n      );\r\n    }\r\n    elementsToPrint.push(document.head);\r\n    printElements(elementsToPrint);\r\n    return {\r\n      success: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   *   \r\n   * @return {Promise<{}>}\r\n   */\r\n  async doActionScrollToElement() {\r\n    let elementId = this.getProperty('element_id');\r\n    if (!elementId) {\r\n      return {success: true};\r\n    }\r\n    elementId = elementId.trim();\r\n    const element = getHTMLElementById(elementId);\r\n    let scroller = window.mainScrollbars;\r\n    if (!scroller) {\r\n      scroller = document.querySelector('.front-app-content');\r\n    }\r\n    if (!scroller) {\r\n      scroller = window;\r\n    }\r\n    if (element) {\r\n      scrollToElement(scroller, element);\r\n    }\r\n    return {\r\n      success: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   *    \r\n   * @return {Promise<{}>}\r\n   */\r\n  async doActionScrollToTop() {\r\n    if (window.mainScrollbars) {\r\n      window.mainScrollbars.scrollTop(0);\r\n      return {\r\n        success: true\r\n      };\r\n    }\r\n    let scroller = document.querySelector('.front-app-content');\r\n\r\n    if (!scroller) {\r\n      scroller = window;\r\n    }\r\n    scroller.scrollTo({top: 0, left: 0, behavior: 'smooth'})\r\n\r\n    return {\r\n      success: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   *    \r\n   * @return {Promise<{}>}\r\n   */\r\n  async doActionScrollToBottom() {\r\n    const routeContent = document.getElementById('route-content');\r\n    if (!routeContent) {\r\n      return {\r\n        success: true\r\n      };\r\n    }\r\n    if (window.mainScrollbars) {\r\n      window.mainScrollbars.scrollTop(routeContent.offsetHeight);\r\n      return {\r\n        success: true\r\n      };\r\n    }\r\n\r\n    let scroller = document.querySelector('.front-app-content');\r\n\r\n    if (!scroller) {\r\n      scroller = window;\r\n    }\r\n    scroller.scrollTo({left: 0, top: document.querySelector('.route-content').offsetHeight, behavior: 'smooth'})\r\n    return {\r\n      success: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   *   PDF\r\n   * @return {Promise<{}>}\r\n   */\r\n  async doActionPageToPDF() {\r\n    let filename = replaceContentWithData(this.getProperty('name', 'file'), this.getCurrentModel().getData());\r\n    const elements = [];\r\n\r\n    elements.push(document.getElementById('route-content'));\r\n    return await elementsToPdf(elements, filename);\r\n  }\r\n\r\n  /**\r\n   *   PDF\r\n   * @return {Promise<{}>}\r\n   */\r\n  async doActionElementsToPDF() {\r\n    let filename = replaceContentWithData(this.getProperty('name', 'file'), this.getCurrentModel().getData());\r\n    const elements = [];\r\n    let IDs = this.getProperty('elements_ids');\r\n    if (!IDs) {\r\n      return {success: true};\r\n    }\r\n    IDs = IDs.split(',');\r\n    IDs.forEach(elementId => {\r\n      if (!elementId || !elementId.trim()) {\r\n        return;\r\n      }\r\n      getHTMLElementById(elementId.trim()) &&\r\n      elements.push(getHTMLElementById(elementId));\r\n    });\r\n    return await elementsToPdf(elements, filename);\r\n  }\r\n\r\n  /**\r\n   *   CSV-\r\n   * @return {Promise<{}>}\r\n   */\r\n  async doActionDataToCSV() {\r\n    let data = getDataByPath(this.getProperty('path'));\r\n    let filename = replaceContentWithData(this.getProperty('name', 'file'), this.getCurrentModel().getData());\r\n    try {\r\n      return await dataToCSV(data, filename);\r\n    } catch (error) {\r\n      console.error(error);\r\n      return {success: false};\r\n    }\r\n  }\r\n\r\n  /**\r\n   * HTML-  CSV-\r\n   * @return {Promise<{}>}\r\n   */\r\n  async doActionTableToCSV() {\r\n    let elementId = this.getProperty('element_id');\r\n    if (!elementId) {\r\n      return {success: true};\r\n    }\r\n    elementId = elementId.trim();\r\n    const element = getHTMLElementById(elementId);\r\n    if (!element) {\r\n      return {success: true};\r\n    }\r\n    let data;\r\n    try {\r\n      data = dataFromTable(element);\r\n    } catch (error) {\r\n      console.error(error);\r\n      return {success: false};\r\n    }\r\n    if (_.isEmpty(data)) {\r\n      return {success: true};\r\n    }\r\n    let filename = replaceContentWithData(this.getProperty('name', 'file'), this.getCurrentModel().getData());\r\n    try {\r\n      return await dataToCSV(data, filename);\r\n    } catch (error) {\r\n      console.error(error);\r\n      return {success: false};\r\n    }\r\n  }\r\n\r\n  /**\r\n   * HTML-  XML-\r\n   * @return {Promise<{}>}\r\n   */\r\n  async doActionTableToXML() {\r\n    let elementId = this.getProperty('element_id');\r\n    if (!elementId) {\r\n      return {success: true};\r\n    }\r\n    elementId = elementId.trim();\r\n    const element = getHTMLElementById(elementId);\r\n    if (!element) {\r\n      return {success: true};\r\n    }\r\n    let data;\r\n    try {\r\n      data = dataFromTable(element);\r\n    } catch (error) {\r\n      console.error(error);\r\n      return {success: false};\r\n    }\r\n    if (_.isEmpty(data)) {\r\n      return {success: true};\r\n    }\r\n    let filename = replaceContentWithData(this.getProperty('name', 'file'), this.getCurrentModel().getData());\r\n    try {\r\n      return await dataToXML(data, filename);\r\n    } catch (error) {\r\n      console.error(error);\r\n      return {success: false};\r\n    }\r\n  }\r\n\r\n  /**\r\n   * HTML-  XLS-\r\n   * @return {Promise}\r\n   */\r\n  async doActionTableToXLS() {\r\n\r\n    let data = [];\r\n\r\n    if (this.getProperty('all_sources')) {\r\n      const all_sources_path = this.getProperty('all_sources_path');\r\n      if (all_sources_path) data = getDataByPath(all_sources_path, {});\r\n      data = {data};\r\n\r\n    } else {\r\n      const elementId = this.getProperty('element_id').trim();\r\n\r\n      if (!elementId) {\r\n        console.error('Element ID is not set');\r\n        return {success: true};\r\n      }\r\n\r\n      const table = getHTMLElementById(elementId);\r\n      if (!table) {\r\n        console.error('Table with provided ID is not found');\r\n        return {success: true};\r\n      }\r\n\r\n      data = dataFromTable(table);\r\n\r\n      const formattedData = [];\r\n\r\n      _.each(data, row => formattedData.push(Object.values(row)));\r\n      let rawTemplateData = this.getProperty('template_data');\r\n      if (rawTemplateData) {\r\n        const parsedTemplateData = rawTemplateData\r\n          .split('\\n')\r\n          .reduce((data, row) => {\r\n            const keyValuePair = row.split('=');\r\n            data[keyValuePair[0]] = keyValuePair[1];\r\n            return data;\r\n          }, {});\r\n        data = {...parsedTemplateData, data: formattedData};\r\n      } else {\r\n        data = {data};\r\n      }\r\n    }\r\n\r\n    const filename = replaceContentWithData(this.getProperty('name', 'file'), this.getCurrentModel().getData());\r\n    const templateName = this.getProperty('template_name');\r\n\r\n    try {\r\n      const blob = await dataToXLS(data, filename, templateName);\r\n      let link = document.createElement('a');\r\n      link.setAttribute('href', window.URL.createObjectURL(blob));\r\n      link.setAttribute('download', filename + '.xlsx');\r\n      document.body.appendChild(link);\r\n      link.click();\r\n      document.body.removeChild(link);\r\n      return {success: true};\r\n    } catch (error) {\r\n      console.error(error);\r\n      return {success: false};\r\n    }\r\n  }\r\n\r\n  /**\r\n   * -\r\n   * @return {Promise<{}>}\r\n   */\r\n  async doActionLogin() {\r\n    /**\r\n     *\r\n     * @member {AltrpForm} form\r\n     */\r\n    let form = this.getProperty('_form');\r\n    let success = true;\r\n    form.fields.forEach(field => {\r\n      if (!field.fieldValidate()) {\r\n        success = false;\r\n      }\r\n    });\r\n    if (!success) {\r\n      return {success: false};\r\n    }\r\n\r\n    return await altrpLogin(form.getData(), this.getFormId());\r\n  }\r\n\r\n  /**\r\n   * -  \r\n   * @return {Promise<{}>}\r\n   */\r\n  async doActionLogout() {\r\n    return await altrpLogout();\r\n  }\r\n\r\n  /**\r\n   * -     `path`\r\n   * @return {Promise<{}>}\r\n   */\r\n  async doActionSetData() {\r\n    let paths = this.getProperty('path');\r\n    const result = {\r\n      success: true\r\n    };\r\n    if (!paths) {\r\n      return result;\r\n    }\r\n    if (paths.indexOf(',') !== -1) {\r\n      paths = paths.split(',').map(path => path.trim());\r\n    } else {\r\n      paths = [paths];\r\n    }\r\n    for (let path of paths) {\r\n      path = replaceContentWithData(path, this.getCurrentModel().getData());\r\n      let value = this.getProperty('value') || '';\r\n      value = value.trim();\r\n      const setType = this.getProperty('set_type');\r\n      let count = this.getProperty('count');\r\n      switch (setType) {\r\n        case 'toggle': {\r\n          value = !getDataByPath(path);\r\n          result.success = setDataByPath(path, value);\r\n        }\r\n          break;\r\n        case 'set': {\r\n          if (\r\n            value.split(/\\r?\\n/).length === 1 &&\r\n            value.indexOf('{{') === 0 &&\r\n            value.indexOf('}}') === value.length - 2\r\n          ) {\r\n            value = getDataByPath(\r\n              value.replace('{{', '').replace('}}', ''),\r\n              null,\r\n              this.getCurrentModel()\r\n            );\r\n          } else if (value.indexOf('|') !== -1) {\r\n            value = parseParamsFromString(\r\n              value,\r\n              this.getCurrentModel(),\r\n              true\r\n            );\r\n          }\r\n          result.success = setDataByPath(path, value);\r\n        }\r\n          break;\r\n        case 'toggle_set': {\r\n          let currentValue = getDataByPath(path);\r\n          value = value.split('\\n').map(v => v.trim());\r\n          if (value.length === 1) {\r\n            value.push('');\r\n          }\r\n          let nextIndex = value.indexOf(currentValue) + 1;\r\n          if (nextIndex >= value.length) {\r\n            nextIndex = 0;\r\n          }\r\n          value = value[nextIndex] || '';\r\n          result.success = setDataByPath(path, value);\r\n        }\r\n          break;\r\n        case 'increment': {\r\n          let currentValue = getDataByPath(path);\r\n          currentValue = currentValue\r\n            ? _.isNaN(Number(currentValue))\r\n              ? 1\r\n              : Number(currentValue)\r\n            : Number(!!currentValue);\r\n          count = Number(count) || 1;\r\n          currentValue += count;\r\n          result.success = setDataByPath(path, currentValue);\r\n        }\r\n          break;\r\n        case 'decrement': {\r\n          let currentValue = getDataByPath(path);\r\n          currentValue = currentValue\r\n            ? _.isNaN(Number(currentValue))\r\n              ? 1\r\n              : Number(currentValue)\r\n            : Number(!!currentValue);\r\n          count = Number(count) || 1;\r\n          currentValue -= count;\r\n          result.success = setDataByPath(path, currentValue);\r\n        }\r\n          break;\r\n        case 'push_items': {\r\n          let currentValue = getDataByPath(path);\r\n          let item = {};\r\n          if (!_.isArray(currentValue)) {\r\n            currentValue = [];\r\n          }\r\n          currentValue = [...currentValue];\r\n          if (_.isObject(getDataByPath(value))) {\r\n            item = getDataByPath(value);\r\n          }\r\n          count = Number(count) || 1;\r\n          if (count < 0) {\r\n            count = 1;\r\n          }\r\n          while (count) {\r\n            _.isArray(item)\r\n              ? currentValue.push([...item])\r\n              : currentValue.push({...item});\r\n            --count;\r\n          }\r\n          result.success = setDataByPath(path, currentValue);\r\n        }\r\n          break;\r\n        case 'remove_items': {\r\n          let items = path.split(/\\r?\\n/);\r\n          items.forEach(i => {\r\n            if (!i) {\r\n              return;\r\n            }\r\n            i = i.trim();\r\n            if (!i) {\r\n              return;\r\n            }\r\n            if (i.indexOf('{{') !== -1) {\r\n              i = replaceContentWithData(i, this.getCurrentModel().getData());\r\n            }\r\n            let item = getDataByPath(i);\r\n            if (!item) {\r\n              return;\r\n            }\r\n            let listPath = i.replace(/.\\d+$/, '').trim();\r\n            if (!listPath) {\r\n              return;\r\n            }\r\n            let list = getDataByPath(listPath);\r\n            if (!_.isArray(list)) {\r\n              return;\r\n            }\r\n            list = [...list];\r\n\r\n            list = list.filter(_item => _item !== item);\r\n            setDataByPath(listPath, list);\r\n          });\r\n          result.success = true;\r\n        }\r\n          break;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   *  -    \r\n   * @return {Promise<{}>}\r\n   */\r\n  doActionFormsManipulate() {\r\n    let IDs = this.getProperty('elements_ids');\r\n    if (!IDs) {\r\n      return {success: true};\r\n    }\r\n    IDs = IDs.split(',');\r\n    const change = this.getProperty('forms_change');\r\n    IDs.forEach(id => {\r\n      let component = getComponentByElementId(id);\r\n      switch (change) {\r\n        case 'select_all': {\r\n          if (_.get(component, 'elementRef.current.selectAll')) {\r\n            component.elementRef.current.selectAll();\r\n          }\r\n        }\r\n          break;\r\n        case 'clear': {\r\n          if (_.get(component, 'elementRef.current.clearValue')) {\r\n            component.elementRef.current.clearValue();\r\n          }\r\n        }\r\n          break;\r\n      }\r\n    });\r\n    return {success: true};\r\n  }\r\n\r\n  /**\r\n   *  -   \r\n   * @return {Promise<{}>}\r\n   */\r\n  async doActionCustomCode() {\r\n    let code = this.getProperty('code');\r\n    try {\r\n      code = replaceContentWithData(code, this.getCurrentModel().getData())\r\n      eval(code);\r\n      return {success: true};\r\n    } catch (error) {\r\n      console.error('Evaluate error in doActionCustomCode: \"' + error.message + '\"');\r\n      return {success: false};\r\n    }\r\n  }\r\n\r\n  /**\r\n   *  -     AJAX\r\n   * Action - updating the current model via AJAX\r\n   * @return {Promise<{}>}\r\n   */\r\n  async doActionUpdateCurrentModel() {\r\n\r\n    let modelName = window?.currentPage?.model_name\r\n    if (!modelName) {\r\n      return {success: true}\r\n    }\r\n    let modelId = window?.model_data?.id;\r\n    if (!modelId) {\r\n      return {success: true}\r\n    }\r\n    try {\r\n      let model = await new Resource({\r\n        route: `/ajax/models/${modelName}`\r\n      }).get(modelId);\r\n      if (_.isObject(model.data)) {\r\n        model = model.data\r\n      }\r\n      const oldModel = window.appStore.getState().currentModel.getData();\r\n      model.altrpModelUpdated = true;\r\n\r\n      if (!_.isEqual(model, oldModel)) {\r\n        appStore.dispatch(changeCurrentModel({altrpModelUpdated: false}));\r\n        appStore.dispatch(changeCurrentModel(model));\r\n      }\r\n      return {success: true}\r\n\r\n    } catch (e) {\r\n      console.error(e);\r\n    }\r\n  }\r\n\r\n  /**\r\n   *  -   \r\n   * @return {Promise<{}>}\r\n   */\r\n  async doActionUpdateCurrentDatasources() {\r\n    let aliases = this.getProperty('aliases') || '';\r\n    aliases = aliases\r\n      .split(',')\r\n      .map(alias => alias.trim())\r\n      .filter(alias => alias);\r\n    const allDataSources = window.dataStorageUpdater.getProperty(\r\n      'currentDataSources'\r\n    );\r\n    const dataSourcesToUpdate = allDataSources.filter(dataSource => {\r\n      return aliases.indexOf(dataSource.getProperty('alias')) !== -1;\r\n    });\r\n    /**\r\n     * @type {DataStorageUpdater}\r\n     */\r\n    await window.dataStorageUpdater.updateCurrent(dataSourcesToUpdate, false);\r\n    return {success: true};\r\n  }\r\n\r\n  /**\r\n   *     \r\n   * @return {Promise<{}>}\r\n   */\r\n  async doActionTrigger() {\r\n    let elementId = this.getProperty('element_id');\r\n    let element = getComponentByElementId(elementId);\r\n    let action = this.getProperty('action');\r\n    if (_.isFunction(element[action])) {\r\n      element[action]();\r\n      return {\r\n        success: true\r\n      };\r\n    }\r\n    try {\r\n      if(_.isFunction(element.elementRef.current[action])){\r\n        let result = await element.elementRef.current[action]();\r\n        if(_.isObject(result)){\r\n          return result\r\n        }\r\n        return {success:true}\r\n      }\r\n      element.elementRef.current.fireAction(action);\r\n      return {\r\n        success: true\r\n      };\r\n    } catch (error) {\r\n      console.error(error);\r\n      return {\r\n        success: false\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   *  \r\n   */\r\n  async doActionEmail() {\r\n    let templateGUID = this.getProperty('email_template');\r\n    if (!templateGUID) {\r\n      return {success: true};\r\n    }\r\n    let res = {success: false};\r\n    try {\r\n      res = await sendEmail(\r\n        templateGUID,\r\n        this.getReplacedProperty('subject'),\r\n        this.getReplacedProperty('from'),\r\n        this.getReplacedProperty('to'),\r\n        this.getReplacedProperty('attachments')\r\n      );\r\n    } catch (e) {\r\n      console.error(e);\r\n      return {\r\n        success: false\r\n      };\r\n    }\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   *     \r\n   */\r\n  async doActionDelay() {\r\n    await delay(this.getProperty('milliseconds') || 0);\r\n    return {success: true};\r\n  }\r\n\r\n  /**\r\n   *  \r\n   * @return {Promise<{success: boolean}>}\r\n   */\r\n  async doActionPlaySound() {\r\n    const duration = this.getProperty('milliseconds') || 0;\r\n    const url = this.getProperty('media_url');\r\n    const loop = this.getProperty('loop');\r\n    if (url) {\r\n      const {playSound} = await import(/* webpackChunkName: 'helpers-sounds' */'../helpers/sounds');\r\n      playSound(url, loop, duration);\r\n      await delay(20);\r\n    }\r\n    return {success: true};\r\n  }\r\n\r\n  /**\r\n   *  \r\n   * @return {Promise<{success: boolean}>}\r\n   */\r\n  async doActionCondition() {\r\n    const compare = this.getProperty('compare');\r\n    let conditionLeft = this.getProperty('condition_left');\r\n    let conditionRight = this.getProperty('condition_right');\r\n    conditionLeft = getDataByPath(conditionLeft, null , this.getCurrentModel().getData());\r\n    conditionRight = replaceContentWithData(conditionRight, this.getCurrentModel().getData());\r\n    const res = altrpCompare(conditionLeft, conditionRight, compare);\r\n    return {success: res};\r\n  }\r\n\r\n  metaMaskConnect = async () => {\r\n    let path = this.getProperty('path');\r\n    let currentValue = getDataByPath(path); //   ,   null\r\n\r\n    if (!window.ethereum) {\r\n      return {\r\n        success: false\r\n      };\r\n    }\r\n\r\n    const accounts = await window.ethereum.request({\r\n      method: \"eth_accounts\",\r\n    });\r\n    if (accounts.length > 0) {\r\n      return {\r\n        success: false\r\n      };\r\n    } else {\r\n      const requestAccounts = await window.ethereum.request({\r\n        method: \"eth_requestAccounts\",\r\n      });\r\n      setDataByPath(path, requestAccounts[0])\r\n      return {\r\n        success: true\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   *    \r\n   * @return {Promise<void>}\r\n   */\r\n  async doActionVIToggle() {\r\n    try {\r\n      const {loadVIPlugin} = (await import(/* webpackChunkName 'loadVIPlugin' */'../helpers/plugins'))\r\n      await loadVIPlugin();\r\n    } catch (error) {\r\n      return {\r\n        success: false\r\n      };\r\n    }\r\n    // console.log($);\r\n    let HTMLWrapper = getWrapperHTMLElementByElement(this.getElement());\r\n    // if(HTMLWrapper){\r\n    //   HTMLWrapper.classList.add('bvi-hide');\r\n    // }\r\n\r\n    // $.bvi({\r\n    //   bvi_target: '.altrp-btn',\r\n    //\r\n    // });\r\n\r\n    return {\r\n      success: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns {Promise<void>}\r\n   */\r\n  async doActionOAuth() {\r\n    const OIDC  = await import (/* webpackChunkName: 'OIDC' */\"oidc-client\");\r\n    const {WebStorageStateStore, UserManager, authority, OidcClient} = OIDC;\r\n    (window.altrpLibs = window.altrpLibs || {}).OIDC = OIDC\r\n\r\n    const method = this.getProperty('method')\r\n    if( ! method){\r\n      return {\r\n        success: true,\r\n      }\r\n    }\r\n    let settings = {\r\n      client_id: 'AisOrder',\r\n      redirect_uri: `http://zayavka.geobuilder.ru/login/laravelpassport/callback`,\r\n      post_logout_redirect_uri: `http://zayavka.geobuilder.ru/login/laravelpassport/callback`,\r\n      response_type: 'token id_token',\r\n      scope: 'openid profile',\r\n      authority:'https://fs.geobuilder.ru/idp',\r\n      automaticSilentRenew: false,\r\n      userStore: new WebStorageStateStore({ store: window.localStorage }),\r\n      filterProtocolClaims: true,\r\n      loadUserInfo: true,\r\n      monitorSession: false,\r\n      checkSessionInterval: 3600000\r\n    };\r\n    const _manager = new UserManager(settings);\r\n    console.log(_manager);\r\n    settings = {\r\n      client_id: this.getProperty('client_id'),\r\n      redirect_uri: this.getProperty('redirect_uri'),\r\n      post_logout_redirect_uri: this.getProperty('post_logout_redirect_uri'),\r\n      response_type: this.getProperty('response_type'),\r\n      scope: this.getProperty('scope'),\r\n      authority:this.getProperty('authority'),\r\n      automaticSilentRenew: this.getProperty('automaticSilentRenew'),\r\n      userStore: new WebStorageStateStore({ store: window.localStorage }),\r\n      filterProtocolClaims: this.getProperty('filterProtocolClaims'),\r\n      loadUserInfo: this.getProperty('loadUserInfo'),\r\n      monitorSession: this.getProperty('monitorSession'),\r\n      checkSessionInterval: this.getProperty('checkSessionInterval')\r\n    };\r\n    const manager = new UserManager(settings);\r\n    // console.log( manager);\r\n    // console.log(await manager.getUser());\r\n    let result;\r\n    console.log(method);\r\n\r\n    if(_.isFunction(manager[method])){\r\n      try {\r\n        result =await manager[method]();\r\n      } catch (e) {\r\n        return {success:false}\r\n      }\r\n    }\r\n    console.log(result);\r\n    // await manager.signoutRedirect();\r\n    return {success:true}\r\n  }\r\n}\r\n\r\nexport default AltrpAction;\r\n","/**\r\n * @class ActionsManager\r\n *             \r\n * @member {} data -         {\r\n *  widgetId:{\r\n *    eventName: []\r\n *  }\r\n * }\r\n */\r\nimport AltrpAction from \"../AltrpAction\";\r\nimport AltrpModel from \"../../../../../editor/src/js/classes/AltrpModel\";\r\nconst {isEditor, } = window.altrpHelpers;\r\n\r\nclass ActionsManager extends AltrpModel{\r\n  /**\r\n   *     \r\n   * @param {string} widgetId\r\n   * @param {array} actions\r\n   * @param {string} eventName\r\n   * @param {FrontElement | null} element\r\n   * @param {*} context\r\n   */\r\n  registerWidgetActions(widgetId, actions = [], eventName = 'click', element = null, context = null ){\r\n    if((! actions) || ! actions.length){\r\n      return null;\r\n    }\r\n    actions = actions.filter(a=>a.type).map(a=>{\r\n      return new AltrpAction(a, widgetId, element);\r\n    });\r\n    return this.setProperty(`actions.${widgetId}.${eventName}`, actions);\r\n  }\r\n\r\n  /**\r\n   *    \r\n   * @param {string} widgetId\r\n   */\r\n  unregisterWidgetActions(widgetId){\r\n    return this.unsetProperty(`actions.${widgetId}`)\r\n  }\r\n\r\n  /**\r\n   *        \r\n   * @param {string} widgetId\r\n   * @param {string} eventName\r\n   * @param {[]} preventedActions\r\n   * @param {FrontElement} element\r\n   * @return {Promise<void>}\r\n   */\r\n  async callAllWidgetActions(widgetId, eventName = 'click', preventedActions, element){\r\n    if(isEditor()){\r\n      return\r\n    }\r\n    if(this.getProperty(`widget.statuses.${widgetId}.${eventName}`) === 'inAction'){\r\n      return\r\n    }\r\n    this.setProperty(`widget.statuses.${widgetId}.${eventName}`, 'inAction')\r\n    preventedActions = preventedActions || [];\r\n    let actions = preventedActions;\r\n    const errors = [];\r\n    actions = actions.map(a=> new AltrpAction(a, widgetId, element))\r\n    // if(! actions.length && preventedActions.length && element){\r\n    //   this.registerWidgetActions(widgetId, preventedActions, eventName, element);\r\n    //   actions = this.getProperty(`actions.${widgetId}.${eventName}`, []);\r\n    // }\r\n    for (let action of actions){\r\n      try {\r\n        let result = await action.doAction();\r\n        if(! result.success){\r\n          if(result.error){\r\n            console.error(result.error);\r\n            errors.push(result.error);\r\n          }\r\n          break;\r\n        }\r\n      } catch(error){\r\n        errors.push(error);\r\n        console.error(error);\r\n      }\r\n    }\r\n    this.setProperty(`widget.statuses.${widgetId}.${eventName}`, 'noAction')\r\n    if (errors.length){\r\n      return {\r\n        success: false,\r\n        errors\r\n      }\r\n    }\r\n    return {success: true};\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @type {ActionsManager}\r\n */\r\nwindow.actionsManager = new ActionsManager;\r\nexport default window.actionsManager\r\n","import {changeCurrentEmailTemplate} from \"../store/current-email-template/actions\";\r\nimport {delay} from '../helpers';\r\nimport Resource from \"../../../../editor/src/js/classes/Resource\";\r\n/**\r\n *     \r\n * @param {string | null}emailTemplateGUID\r\n * @param {string} subject\r\n * @param {string} from\r\n * @param {string} to\r\n * @param {string} attachments\r\n * @return {Promise<void>}\r\n */\r\nexport async function sendEmail(emailTemplateGUID = null, subject = 'Message', from = '', to = '', attachments = ''){\r\n  if(! emailTemplateGUID){\r\n    return {success: true};\r\n  }\r\n  let templateLoader = (await import(/* webpackChunkName: 'TemplateLoader' */'../../../../editor/src/js/classes/modules/TemplateLoader')).default;\r\n  let template = await templateLoader.loadTemplate(emailTemplateGUID);\r\n  appStore.dispatch(changeCurrentEmailTemplate(template));\r\n  let html = '';\r\n  do{\r\n    await delay(1500);\r\n    if(_.get(window, 'emailTemplatesRenderer.emailTemplate.current')){\r\n      /**\r\n       * @var  {HTMLElement} html\r\n       */\r\n      html = window.emailTemplatesRenderer.emailTemplate.current.cloneNode(true);\r\n      html.style.display = 'table';\r\n      html = html.outerHTML;\r\n    }\r\n  }while(! html);\r\n  // appStore.dispatch(changeCurrentEmailTemplate(null));\r\n  const resource = new Resource({route: '/ajax/feedback-html'});\r\n  let res = await resource.post(\r\n    {\r\n      subject,\r\n      to,\r\n      from,\r\n      html,\r\n      attachments,\r\n    }\r\n  );\r\n  return {success: true}\r\n}\r\n"],"sourceRoot":""}